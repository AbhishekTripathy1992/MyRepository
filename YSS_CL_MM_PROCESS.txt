

METHOD fetch_po_list.
*----------------------------------------------------------------------*
*                    A D M I N I S T R A T I O N
*----------------------------------------------------------------------*
* Organization: Incresol Software Services Private Limited             *
* Created by  : Zareena Begum                                          *
* Created on  : 16-Mar-2018                                            *
* Description : Fetch purchase order list                              *
*----------------------------------------------------------------------*
*                       C H A N G E    L O G
*----------------------------------------------------------------------*
* <Changed by> | <Changed on> | <Change ID> like USERNAME.DDMMYY
* <Description of change>
*----------------------------------------------------------------------*

TYPES : BEGIN OF lty_ekko,
ebeln TYPE ebeln,
bukrs TYPE bukrs,
bstyp TYPE ebstyp,
bsart TYPE esart,
loekz TYPE eloek,
statu TYPE estak,
lifnr TYPE lifnr,
bedat TYPE ebdat,
ihrez TYPE ihrez,
frgke TYPE frgke,
kunnr TYPE kunnr,
END OF lty_ekko,
BEGIN OF lty_ekpo,
ebeln TYPE ebeln,
ebelp TYPE ebelp,
loekz TYPE loekz,
menge	TYPE bstmg,
werks TYPE werks_d,
netwr	TYPE bwert,
effwr TYPE effwr,
END OF lty_ekpo,
BEGIN OF lty_lfa1,
lifnr TYPE lifnr,
name1 TYPE name1_gp,
name2 TYPE name2_gp,
END OF lty_lfa1,
BEGIN OF lty_me2n_re_op,
ebeln      TYPE ebeln,
bedat      TYPE bedat,
superfield TYPE merep_super,
bsart      TYPE bsart,
ebelp      TYPE ebelp,
ematn      TYPE matnr,
loekz      TYPE loekz,
txz01      TYPE txz01,
menge      TYPE bstmg,
meins      TYPE meins,
netpr      TYPE netpr,
netwr      TYPE netwr,
waers      TYPE waers,
mglief     TYPE merep_mglief,
wtlief     TYPE merep_wtlief,
mginv      TYPE merep_mginv,
wtinv      TYPE merep_wtinv,
END OF lty_me2n_re_op.
DATA : lt_ekko       TYPE TABLE OF lty_ekko,
lt_ekko_temp  TYPE TABLE OF lty_ekko,
lt_ekpo       TYPE TABLE OF lty_ekpo,
lt_ekpo_total TYPE TABLE OF lty_ekpo,
lt_lfa1       TYPE TABLE OF lty_lfa1,
lv_netwr      TYPE netwr,
lv_netwr_base TYPE netwr,
lt_tvarvc     TYPE rsdsselopt_t,
lwa_tvarvc    TYPE LINE OF rsdsselopt_t,
lv_from_date  TYPE sy-datum,
lt_r_lifnr    TYPE RANGE OF lifnr,
lt_r_frgke    TYPE RANGE OF frgke,
lt_r_ebeln    TYPE RANGE OF ebeln,
lt_r_date     TYPE yss_cl_type_pool=>yss_r_date,
lo_exception  TYPE REF TO ycx_ss_exception,
lt_me2n_re_op TYPE TABLE OF lty_me2n_re_op,
lv_mglief     TYPE merep_mglief,
lv_mginv      TYPE merep_mginv,
lv_menge      TYPE bstmg,
lr_pay_data   TYPE REF TO data,
ls_seltab     TYPE rsparams,
lt_seltab     TYPE TABLE OF rsparams,
lv_plant_name TYPE name1,
lt_kna1       TYPE TABLE OF yss_s_cust.

FIELD-SYMBOLS : <lfs_ekko>    TYPE lty_ekko,
<lfs_ekpo>    TYPE lty_ekpo,
<lfs_date>    TYPE LINE OF yss_cl_type_pool=>yss_r_d
<lt_pay_data> TYPE ANY TABLE.

*If PO Number is given
IF im_ebeln IS NOT INITIAL.
APPEND INITIAL LINE TO lt_r_ebeln ASSIGNING FIELD-SYMBOL(<lfs_r_eb
<lfs_r_ebeln>-sign = 'I'.
<lfs_r_ebeln>-option = 'EQ'.
<lfs_r_ebeln>-low = im_ebeln.
ENDIF.

*If Vendor number is given
IF im_lifnr IS NOT INITIAL.
APPEND INITIAL LINE TO lt_r_lifnr ASSIGNING FIELD-SYMBOL(<lfs_r_li
<lfs_r_lifnr>-sign = 'I'.
<lfs_r_lifnr>-option = 'EQ'.
<lfs_r_lifnr>-low = im_lifnr.
ENDIF.

*If im_status is given (B for blocked PO's / R for released PO's)
IF im_status IS NOT INITIAL.
APPEND INITIAL LINE TO lt_r_frgke ASSIGNING FIELD-SYMBOL(<lfs_r_fr
<lfs_r_frgke>-sign = 'I'.
<lfs_r_frgke>-option = 'EQ'.
<lfs_r_frgke>-low = im_status.
ELSE.
APPEND INITIAL LINE TO lt_r_frgke ASSIGNING <lfs_r_frgke>.
<lfs_r_frgke>-sign = 'I'.
<lfs_r_frgke>-option = 'EQ'.
<lfs_r_frgke>-low = yss_cl_type_pool=>yss_c_b.
APPEND INITIAL LINE TO lt_r_frgke ASSIGNING <lfs_r_frgke>.
<lfs_r_frgke>-sign = 'I'.
<lfs_r_frgke>-option = 'EQ'.
<lfs_r_frgke>-low = yss_cl_type_pool=>yss_c_r.
ENDIF.

* To fill lt_r_date (get list of  PO for last 1 month)
IF im_date IS INITIAL.
*If im_date is initial, Get no. of days from TVARVC table
CALL METHOD yss_cl_util=>get_tvarvc_entries
EXPORTING
im_tvarvc_name = yss_cl_type_pool=>yss_c_po_days
IMPORTING
ex_range       = lt_tvarvc.
READ TABLE lt_tvarvc INTO lwa_tvarvc INDEX 1.
IF sy-subrc EQ 0.
lv_from_date = sy-datum - lwa_tvarvc-low.
APPEND INITIAL LINE TO lt_r_date ASSIGNING <lfs_date>.
<lfs_date>-sign = 'I'.
<lfs_date>-option = 'BT'.
<lfs_date>-low = lv_from_date.
<lfs_date>-high = sy-datum.
ENDIF.
ELSE.
APPEND INITIAL LINE TO lt_r_date ASSIGNING <lfs_date>.
<lfs_date>-sign = 'I'.
<lfs_date>-option = 'BT'.
<lfs_date>-low = im_date-low.
<lfs_date>-high = im_date-high.
ENDIF.

*Get PO header details
SELECT ebeln
bukrs
bstyp
bsart
loekz
statu
lifnr
bedat
ihrez
frgke FROM ekko
INTO TABLE lt_ekko
WHERE bukrs = yss_cl_type_pool=>yss_c_rmss AND
ebeln IN lt_r_ebeln AND
bedat IN lt_r_date  AND
frgke IN lt_r_frgke AND
lifnr IN lt_r_lifnr ORDER BY PRIMARY KEY.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>po_not_found
msgv1  = ycx_ss_exception=>format( im_req_params-werks )
msgv2  = ycx_ss_exception=>format( 'for the given period' ).
ELSE.
*Get PO item details
SELECT ebeln
ebelp
loekz
menge
werks
netwr
effwr FROM ekpo
INTO TABLE lt_ekpo
FOR ALL ENTRIES IN lt_ekko
WHERE ebeln = lt_ekko-ebeln AND
werks = im_req_params-werks AND
loekz NE yss_cl_type_pool=>yss_c_l.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>po_item_not_found
msgv1  = ycx_ss_exception=>format( im_req_params-werks ).
ENDIF.

*Get vendor name
SELECT lifnr
name1 name2
FROM lfa1
INTO TABLE lt_lfa1
FOR ALL ENTRIES IN lt_ekko
WHERE lifnr = lt_ekko-lifnr ORDER BY PRIMARY KEY.
IF sy-subrc EQ 0.
ENDIF.
lt_ekko_temp = lt_ekko.
SORT lt_ekko_temp BY ihrez.
DELETE ADJACENT DUPLICATES FROM lt_ekko_temp COMPARING ihrez.
LOOP AT lt_ekko_temp ASSIGNING FIELD-SYMBOL(<lfs_ekko_temp>).
CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = <lfs_ekko_temp>-ihrez
IMPORTING
output = <lfs_ekko_temp>-ihrez.
<lfs_ekko_temp>-kunnr = <lfs_ekko_temp>-ihrez+2(10).
ENDLOOP.
SELECT kunnr
name1
FROM kna1
INTO TABLE lt_kna1
FOR ALL ENTRIES IN lt_ekko_temp WHERE kunnr = lt_ekko_temp-kunnr
IF sy-subrc EQ 0.
SORT lt_kna1 BY cust_id.
ENDIF.
ENDIF.

SELECT SINGLE name1 FROM t001w INTO lv_plant_name  WHERE werks = im_
*--------------------------------------------------------------------*
LOOP AT lt_ekpo ASSIGNING FIELD-SYMBOL(<lfs_test>).
ls_seltab-selname = 'EN_EBELN'.
ls_seltab-low     = <lfs_test>-ebeln.
ls_seltab-sign    = 'I'.
ls_seltab-option  = 'EQ'.
APPEND ls_seltab TO lt_seltab.
CLEAR ls_seltab.
ENDLOOP.
cl_salv_bs_runtime_info=>set( EXPORTING display  = abap_false
metadata = abap_false
data     = abap_true ).
SUBMIT rm06en00 WITH listu = 'ALV'
WITH SELECTION-TABLE lt_seltab
AND RETURN.
cl_salv_bs_runtime_info=>get_data_ref( IMPORTING r_data = lr_pay_dat
ASSIGN lr_pay_data->* TO <lt_pay_data>.
MOVE-CORRESPONDING <lt_pay_data> TO lt_me2n_re_op.
DELETE lt_me2n_re_op WHERE loekz EQ yss_cl_type_pool=>yss_c_l.
SORT lt_me2n_re_op BY ebeln.
*--------------------------------------------------------------------*
*prepare final table
SORT lt_ekpo BY ebeln. "+++hana
LOOP AT lt_ekpo ASSIGNING <lfs_ekpo>.
*      lv_netwr = lv_netwr + <lfs_ekpo>-netwr.
lv_netwr = lv_netwr + <lfs_ekpo>-effwr.
lv_netwr_base = lv_netwr_base + <lfs_ekpo>-netwr.
AT END OF ebeln.
APPEND INITIAL LINE TO ex_po_list ASSIGNING FIELD-SYMBOL(<lfs_po
READ TABLE lt_ekko  ASSIGNING <lfs_ekko> WITH KEY ebeln = <lfs_e
IF sy-subrc EQ 0.
<lfs_po_list>-po_number = <lfs_ekko>-ebeln.
READ TABLE lt_lfa1 ASSIGNING FIELD-SYMBOL(<lfs_lfa1>) WITH KEY
IF sy-subrc EQ 0.
CONCATENATE <lfs_lfa1>-name1 <lfs_lfa1>-name2 INTO <lfs_po_l
*            <lfs_po_list>-vendor_name = <lfs_lfa1>-name1.
ENDIF.
<lfs_po_list>-po_date   = <lfs_ekko>-bedat.
<lfs_po_list>-po_amount = lv_netwr.
<lfs_po_list>-base_amount = lv_netwr_base.
<lfs_po_list>-status_id = <lfs_ekko>-frgke.
IF <lfs_ekko>-bsart = 'ZCC' OR <lfs_ekko>-bsart = 'ZNB' OR <lf
<lfs_po_list>-doc_type  = 'Order'.
ELSEIF <lfs_ekko>-bsart = 'ZRN'.
<lfs_po_list>-doc_type  = 'Returns'.
ENDIF.
CASE <lfs_ekko>-frgke.
WHEN yss_cl_type_pool=>yss_c_b.
<lfs_po_list>-status = yss_cl_type_pool=>yss_c_pending.
WHEN yss_cl_type_pool=>yss_c_r.
<lfs_po_list>-status = yss_cl_type_pool=>yss_c_released.
ENDCASE.

CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = <lfs_ekko>-ihrez
IMPORTING
output = <lfs_ekko>-ihrez.
<lfs_po_list>-hospital_code = <lfs_ekko>-ihrez.
READ TABLE lt_kna1 ASSIGNING FIELD-SYMBOL(<lfs_kna1>) WITH KEY
IF sy-subrc EQ 0.
<lfs_po_list>-hospital_name = <lfs_kna1>-cust_name.
ENDIF.
ENDIF.
<lfs_po_list>-plant = <lfs_ekpo>-werks.
<lfs_po_list>-plant_name = lv_plant_name.
*------------------------------for PO delivery status-------------------

LOOP AT lt_me2n_re_op ASSIGNING FIELD-SYMBOL(<lfs_me2n_re_op>) W
lv_menge  = lv_menge  + <lfs_me2n_re_op>-menge.
lv_mglief = lv_mglief + <lfs_me2n_re_op>-mglief.
lv_mginv  = lv_mginv  + <lfs_me2n_re_op>-mginv.
AT END OF ebeln.
CASE <lfs_me2n_re_op>-bsart.
*              WHEN 'ZUB2'.
*                IF lv_menge = lv_mglief.
*                  <lfs_po_list>-po_deliv_status = 'Not delivered/Not In
*                ENDIF.
WHEN OTHERS. "ZCC/ZNB/ZRN/YNB
IF lv_menge = lv_mglief AND lv_menge = lv_mginv.
<lfs_po_list>-po_deliv_status = 'Not delivered/Not Inv
ENDIF.
IF  lv_mglief IS INITIAL AND lv_mginv IS INITIAL.
<lfs_po_list>-po_deliv_status = 'Fully Delivered/Fully
ENDIF.
IF lv_mglief IS INITIAL AND lv_mginv IS NOT INITIAL.
<lfs_po_list>-po_deliv_status = 'Fully Delivered/Not I
ENDIF.
IF lv_menge > lv_mglief AND lv_mglief IS NOT INITIAL AND
<lfs_po_list>-po_deliv_status = 'Partially Delivered/N
ENDIF.
IF lv_menge > lv_mginv AND lv_mginv IS NOT INITIAL AND l
<lfs_po_list>-po_deliv_status = 'Fully Delivered/Parti
ENDIF.
IF lv_menge > lv_mginv  AND lv_mginv  IS NOT INITIAL AND
<lfs_po_list>-po_deliv_status = 'Partially Delivered/P
ENDIF.
ENDCASE.
CLEAR : lv_menge,lv_mglief,lv_mginv.
ENDAT.
ENDLOOP.

*------------------------------for PO delivery status-------------------
CLEAR : lv_netwr,lt_seltab,lv_netwr_base.
ENDAT.
ENDLOOP.
ENDMETHOD.




CREATE_PO
item
METHOD create_po.
*---------------------------------------------------------------*
*                    A D M I N I S T R A T I O N
*---------------------------------------------------------------*
* Organization: Incresol Software Services Private Limited
* Created By  :  Abhishek Tripathy
* Created On  :  19-Mar-2018
* Description :  Generic Method To Create Purchase Order
*---------------------------------------------------------------*
*                       C H A N G E    L O G
*---------------------------------------------------------------*
* <Changed by> | <Changed on> | <Change ID> like USERNAME.DDMMYY
* <Description of change>
*---------------------------------------------------------------*
DATA : ls_return TYPE bapiret2.
*Create Purchase Order
CALL FUNCTION 'BAPI_PO_CREATE'
EXPORTING
po_header                  = im_po_header
po_header_add_data         = im_po_header_add_data
header_add_data_relevant   = im_header_add_data_relevant
po_address                 = im_po_address
skip_items_with_error      = abap_true
item_add_data_relevant     = im_item_add_data_relevant
header_tech_fields         = im_header_tech_fields
IMPORTING
purchaseorder              = ex_purchaseorder
TABLES
po_items                   = im_po_items
po_item_add_data           = im_po_item_add_data
po_item_schedules          = im_po_item_schedules
po_item_account_assignment = im_po_item_account_assignment
po_item_text               = im_po_item_text
return                     = ex_return_bapi
po_limits                  = im_po_limits
po_contract_limits         = im_po_contract_limits
po_services                = im_po_services
po_srv_accass_values       = im_po_srv_accass_values
po_services_text           = im_po_services_text
po_business_partner        = im_po_business_partner
extensionin                = im_extensionin
poaddrdelivery             = im_poaddrdelivery.

*Transaction commit
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait   = abap_true
IMPORTING
return = ls_return.

*Release Locks of an LUW
CALL FUNCTION 'DEQUEUE_ALL'.


ENDMETHOD.
FIND_VENDORS
item
METHOD find_vendors.
*----------------------------------------------------------------------*
*                    A D M I N I S T R A T I O N
*----------------------------------------------------------------------*
* Organization: Incresol Software Services Private Limited             *
* Created by  : Abhishek T                                             *
* Created on  : 20-Mar-2018                                            *
* Description : Generic method to find                                 *
*----------------------------------------------------------------------*
*                       C H A N G E    L O G
*----------------------------------------------------------------------*
* <Changed by> | <Changed on> | <Change ID> like USERNAME.DDMMYY
* <Description of change>
*----------------------------------------------------------------------*
TYPES:BEGIN OF lty_vendor,
lifnr TYPE lifnr,
END OF lty_vendor,
lty_t_vendor TYPE STANDARD TABLE OF lty_vendor.
TYPES : BEGIN OF lty_vendor_list,
lifnr TYPE lifnr,
name1 TYPE ad_name1,
name2 TYPE ad_name2,
END OF lty_vendor_list.
*Data Declarations
DATA:lv_vendor           TYPE char100,
lv_vendor_temp      TYPE char100,
lv_vendor_temp1     TYPE char100,
lv_cond             TYPE char100,
lv_length           TYPE i,
lt_vendor           TYPE lty_t_vendor,
lo_exception        TYPE REF TO ycx_ss_exception,
lt_vendor_list      TYPE TABLE OF lty_vendor_list,
lr_vendor_sales_org TYPE rsdsselopt_t.
**Field-Symbol


*TRY.
CALL METHOD yss_cl_util=>get_tvarvc_entries
EXPORTING
im_tvarvc_name = 'YSS_SO_VENDOR_SALES_ORG'
IMPORTING
ex_range       = lr_vendor_sales_org.
* CATCH ycx_ss_exception .
*ENDTRY.

CLEAR: ex_vendor_list.

CONCATENATE '%' im_vendor '%' INTO lv_vendor.

IF im_vendor CA '123456789'.
lv_vendor_temp1 = im_vendor.
* "Incase the input contains zeroes first
SHIFT lv_vendor_temp1 LEFT DELETING LEADING '0'.
lv_length = strlen( lv_vendor_temp1 ).
**Get list of vendor based on vendor no
SELECT DISTINCT lifnr
FROM lfb1
INTO TABLE lt_vendor
WHERE lifnr LIKE lv_vendor
AND bukrs IN lr_vendor_sales_org AND
loevm NE abap_true.
IF sy-subrc EQ 0.
LOOP AT lt_vendor INTO lv_vendor.
lv_vendor_temp = lv_vendor.
SHIFT lv_vendor_temp LEFT DELETING LEADING '0'.
IF lv_vendor_temp+0(lv_length) NE lv_vendor_temp1.
CLEAR lv_vendor.
MODIFY lt_vendor FROM lv_vendor.
ENDIF.
CLEAR : lv_vendor_temp.
ENDLOOP.
DELETE lt_vendor WHERE lifnr EQ space.
lv_cond = 'lifnr EQ lt_vendor-lifnr'.
ENDIF.
ELSE.
lv_vendor_temp = im_vendor.
TRANSLATE lv_vendor_temp TO UPPER CASE.
IF lv_vendor_temp CA sy-abcde.
**Get list of vendor based on name
SELECT DISTINCT lifnr
FROM lfb1
INTO TABLE lt_vendor
WHERE bukrs IN lr_vendor_sales_org."('RMSS','RMSD')."
IF sy-subrc EQ 0 AND lt_vendor IS NOT INITIAL.
TRANSLATE lv_vendor TO UPPER CASE.
lv_cond = 'lifnr = lt_vendor-lifnr and ( mcod1 like lv_vendor
ENDIF.
ENDIF.
ENDIF.


IF lt_vendor IS NOT INITIAL.
SELECT lifnr name1 name2
FROM lfa1
INTO TABLE lt_vendor_list
FOR ALL ENTRIES IN lt_vendor
WHERE (lv_cond) .
IF sy-subrc EQ 0.
**Do nothing
ENDIF.
ENDIF.
LOOP AT lt_vendor_list ASSIGNING FIELD-SYMBOL(<lfs_vend_list>).
APPEND INITIAL LINE TO ex_vendor_list ASSIGNING FIELD-SYMBOL(<lfs_
<lfs_ex_list>-vendor_id = <lfs_vend_list>-lifnr.
IF <lfs_vend_list>-name2 IS NOT INITIAL.
CONCATENATE <lfs_vend_list>-name1 <lfs_vend_list>-name2 INTO <lf
ELSE.
<lfs_ex_list>-vendor_name =   <lfs_vend_list>-name1 .
ENDIF.
ENDLOOP.

IF ex_vendor_list IS INITIAL.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>vendor_details_not_found.
ENDIF.
ENDMETHOD.
FETCH_PO_DETAILS
item
METHOD fetch_po_details.
CALL FUNCTION 'BAPI_PO_GETDETAIL'
EXPORTING
purchaseorder              = purchaseorder
items                      = abap_true
account_assignment         = abap_true
schedules                  = abap_true
history                    = abap_true
item_texts                 = abap_true
header_texts               = abap_true
services                   = abap_true
confirmations              = abap_true
service_texts              = abap_true
extensions                 = abap_true
IMPORTING
po_header                  = ex_po_header_data
po_address                 = ex_po_address
TABLES
po_header_texts            = ex_po_header_texts
po_items                   = ex_po_items
po_item_account_assignment = ex_po_item_account_assignment
po_item_schedules          = ex_po_item_schedules
po_item_confirmations      = ex_po_item_confirmations
po_item_texts              = ex_po_item_texts
po_item_history            = ex_po_item_history
po_item_history_totals     = ex_po_item_history_totals
po_item_limits             = ex_po_item_limits
po_item_contract_limits    = ex_po_item_contract_limits
po_item_services           = ex_po_item_services
po_item_srv_accass_values  = ex_po_item_srv_accass_values
return                     = ex_return_bapi
po_services_texts          = ex_po_services_texts
extensionout               = ex_extensionout.
IF ex_return_bapi IS NOT INITIAL.
MOVE-CORRESPONDING ex_return_bapi TO ex_return.
ENDIF.

ENDMETHOD.
EDIT_PURCHASE_ORDER
item
METHOD edit_purchase_order.
*----------------------------------------------------------------------*
*                    A D M I N I S T R A T I O N
*----------------------------------------------------------------------*
* Organization: Incresol Software Services Private Limited             *
* Created by  : Zareena Begum                                          *
* Created on  : 22-Mar-2018                                            *
* Description : Edit purchase order                                    *
*----------------------------------------------------------------------*
*                       C H A N G E    L O G
*----------------------------------------------------------------------*
* <Changed by> | <Changed on> | <Change ID> like USERNAME.DDMMYY
* <Description of change>
*----------------------------------------------------------------------*
TYPES: BEGIN OF lty_ekpo,
ebelp TYPE ebelp,
matnr TYPE matnr,
lgort TYPE lgort_d,
werks TYPE ewerk,
END OF lty_ekpo.
TYPES : BEGIN OF lty_mat_prc,
matnr TYPE matnr,
price TYPE kbetr,
END OF lty_mat_prc.
DATA: lt_ekpo          TYPE TABLE OF lty_ekpo,
lwa_ekpo         TYPE lty_ekpo,
ls_return        TYPE bapiret2,
lt_return        TYPE TABLE OF bapiret2,
lt_pocondheader  TYPE yss_tt_bapimepocondheader,
lt_pocond        TYPE yss_tt_bapimepocond,
lt_pocondx       TYPE yss_tt_bapimepocondx,
lv_item_exists   TYPE flag,
lt_poitems       TYPE yss_tt_bapimepoitem,
lt_poitemx       TYPE yss_tt_bapimepoitemx,
lt_schedule      TYPE yss_tt_bapimeposchedule,
lt_poschedulex   TYPE yss_tt_bapimeposchedulx,
*-----------------------------------------------------------------------
lt_mbew          TYPE TABLE OF mbew,
lt_a701          TYPE TABLE OF a701,
lt_konp          TYPE TABLE OF konp,
lt_mat_prc       TYPE TABLE OF lty_mat_prc,
lt_mat_price_po  TYPE yss_tt_mat_price_po,
lt_mat_prc_2     TYPE TABLE OF lty_mat_prc,
ls_t001w         TYPE t001w,
lv_pltyp         TYPE pltyp,
lv_werks         TYPE werks_ext,
lv_kunnr         TYPE kunnr,
lv_net_price     TYPE bprei,
lv_kunwe         TYPE kunwe,
lv_werks_check   TYPE werks_ext,
lt_poshipping    TYPE  TABLE OF bapiitemship,
lt_poshippingx   TYPE  TABLE OF bapiitemshipx,
lt_poshippingexp TYPE TABLE OF bapimeposhippexp,
lt_817           TYPE TABLE OF a817,
** SOC Purna  SNDK902572
lv_werks_shp     TYPE rvari_val_255,
lv_plant         TYPE werks_ext.
** EOC Purna SNDK902572
*-----------------------------------------------------------------------

lt_poitems       = im_poitems.
lt_poitemx       = im_poitemx.
lt_schedule      = im_schedule.
lt_poschedulex   = im_poschedulex.
lt_pocondheader  = im_pocondheader.
lt_pocond        = im_pocond.
lt_pocondx       = im_pocondx.

DATA : lv_lifnr TYPE lifnr.
*--------------------------------------------------------------------*
SELECT SINGLE lifnr FROM ekko INTO lv_lifnr WHERE ebeln = im_poheade
SELECT SINGLE werks
FROM lfa1
INTO lv_werks_check
WHERE lifnr = lv_lifnr."im_poheader-vendor.
IF sy-subrc EQ 0.

ENDIF.
*--
SELECT ebelp
matnr
lgort
werks INTO TABLE lt_ekpo
FROM ekpo
WHERE ebeln = im_ebeln.
IF sy-subrc EQ 0.
"do nothing
ENDIF.

LOOP AT lt_poitems ASSIGNING FIELD-SYMBOL(<lfs_poitems>) .
<lfs_poitems>-plant = im_req_params-werks.
READ TABLE lt_poitemx ASSIGNING FIELD-SYMBOL(<lfs_poitemsx>) WITH
IF sy-subrc EQ 0 AND <lfs_poitemsx>-delete_ind = 'X'.
CONTINUE.
ENDIF.
*For creating a new item
READ TABLE lt_ekpo ASSIGNING FIELD-SYMBOL(<lfs_ekpo>) WITH KEY ebe
mat
IF sy-subrc NE 0 AND <lfs_poitems>-po_item IS NOT INITIAL.
<lfs_poitems>-gr_basediv = abap_true.
<lfs_poitems>-gr_ind     = abap_true.
<lfs_poitems>-ir_ind     = abap_true.
READ TABLE lt_poitemx ASSIGNING FIELD-SYMBOL(<lfs_poitemx>) WITH
IF sy-subrc EQ 0.
<lfs_poitemx>-stge_loc   = abap_true.
<lfs_poitemx>-gr_basediv = abap_true.
<lfs_poitemx>-gr_ind     = abap_true.
<lfs_poitemx>-ir_ind     = abap_true.
<lfs_poitemx>-shipping   = abap_true.
ENDIF.

READ TABLE lt_ekpo INTO lwa_ekpo INDEX 1.
IF sy-subrc EQ 0.
<lfs_poitems>-stge_loc = lwa_ekpo-lgort.
ENDIF.
ENDIF.
IF im_testrun NE 'X'.
READ TABLE ch_item_mat_price ASSIGNING FIELD-SYMBOL(<lfs_item_ma

IF sy-subrc EQ 0.
<lfs_poitems>-net_price = <lfs_item_mat_price>-mat_price.
ENDIF.
ENDIF.
** SOC Purna SNDK902572
*      IF im_req_params-werks+0(1) EQ yss_cl_type_pool=>yss_c_k AND
*         lv_werks_check = '6352'.
IF im_req_params-werks+0(1) EQ yss_cl_type_pool=>yss_c_k.
** Select the value from table TVARVC for shipping point
CLEAR: lv_plant,
lv_werks_shp.
CONCATENATE 'YSS_PO_' lv_werks_check
INTO lv_werks_shp.
SELECT low UP TO 1 ROWS
INTO lv_plant
FROM tvarvc
WHERE name EQ lv_werks_shp
AND  type EQ 'P'.
ENDSELECT.
IF sy-subrc NE 0.
** Do nothing
ENDIF.
** EOC Purna SNDK902572
APPEND INITIAL LINE TO lt_poshipping
ASSIGNING FIELD-SYMBOL(<lfs_poshipping>).
*        IF sy-subrc EQ 0.
<lfs_poshipping>-po_item = <lfs_poitems>-po_item.
*        <lfs_poshipping>-ship_point = 'K352'.  " Purna SNDK902572
<lfs_poshipping>-ship_point = lv_plant. " Purna SNDK902572
*        ENDIF.
APPEND INITIAL LINE TO lt_poshippingx
ASSIGNING FIELD-SYMBOL(<lfs_poshippingx>).
*        IF sy-subrc EQ 0.
<lfs_poshippingx>-po_item = <lfs_poitems>-po_item.
*          <lfs_poshippingx>-po_itemx = abap_true.
<lfs_poshippingx>-ship_point = abap_true.
*        ENDIF.
***        APPEND INITIAL LINE TO lt_poshippingexp
***        ASSIGNING FIELD-SYMBOL(<lfs_poshippingexp>).
***        IF sy-subrc EQ 0.
***          <lfs_poshippingexp>-po_item = <lfs_poitems>-po_item.
****          <lfs_poshippingx>-po_itemx = abap_true.
***          <lfs_poshippingexp>-ship_point = 'K352'.
***        ENDIF.
ENDIF.

ENDLOOP.
*Call BAPI to change PO
CALL FUNCTION 'BAPI_PO_CHANGE'
EXPORTING
purchaseorder = im_ebeln
poheader      = im_poheader
poheaderx     = im_poheaderx
testrun       = im_testrun
IMPORTING
expheader     = ex_header
TABLES
return        = lt_return
poitem        = lt_poitems
poitemx       = lt_poitemx
poschedule    = lt_schedule
poschedulex   = lt_poschedulex
pocondheader  = lt_pocondheader
pocond        = lt_pocond
poshipping    = lt_poshipping
poshippingx   = lt_poshippingx
poshippingexp = lt_poshippingexp
pocondx       = lt_pocondx.
IF im_testrun NE abap_true.
WAIT UP TO 1 SECONDS.
*Bapi transaction commit
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait   = abap_true
IMPORTING
return = ls_return.
IF ls_return IS NOT INITIAL.
APPEND ls_return TO ex_return.
ENDIF.
CALL FUNCTION 'DEQUEUE_ALL'.
ELSE.
LOOP AT lt_pocond ASSIGNING FIELD-SYMBOL(<lfs_cond1>) .
IF <lfs_cond1>-cond_type NE 'JICG' AND
<lfs_cond1>-cond_type NE 'JISG' AND
<lfs_cond1>-cond_type NE 'JIIG'.
DELETE lt_pocond.
ENDIF.
ENDLOOP.

LOOP AT im_poitems ASSIGNING FIELD-SYMBOL(<lfs_item>) .
APPEND INITIAL LINE TO lt_mat_price_po ASSIGNING FIELD-SYMBOL(<l
<lfs_price_po>-item_no = <lfs_item>-po_item.
<lfs_price_po>-mat_id  = <lfs_item>-material.
READ TABLE lt_poitems ASSIGNING FIELD-SYMBOL(<lfs_item1>) WITH K
IF sy-subrc EQ 0.
<lfs_price_po>-uom     = <lfs_item1>-po_unit.
ENDIF.

CALL FUNCTION 'EAN150_MAKT_READ_DESCRIPTION'
EXPORTING
i_matnr         = <lfs_price_po>-mat_id
i_langu         = sy-langu
IMPORTING
e_maktx         = <lfs_price_po>-mat_desc
EXCEPTIONS
wrong_parameter = 1
OTHERS          = 2.

READ TABLE im_schedule ASSIGNING FIELD-SYMBOL(<lfs_sched>) WITH
IF sy-subrc EQ 0.
<lfs_price_po>-mat_quan = <lfs_sched>-quantity.
ENDIF.

LOOP AT lt_pocond ASSIGNING <lfs_cond1> WHERE itm_number = <lfs_
IF <lfs_cond1>-cond_type = 'JICG'.
<lfs_price_po>-cgst_rate = <lfs_cond1>-cond_value.
ENDIF.
IF <lfs_cond1>-cond_type = 'JIIG'.
<lfs_price_po>-igst_rate = <lfs_cond1>-cond_value.
ENDIF.
IF <lfs_cond1>-cond_type = 'JISG'.
<lfs_price_po>-sgst_rate = <lfs_cond1>-cond_value.
ENDIF.
ENDLOOP.
ENDLOOP.
IF im_req_params+0(1) EQ yss_cl_type_pool=>yss_c_s.
*get vendor plant
CASE im_poheader-doc_type.
WHEN 'YNB'.  "RMSS plant
********************************************************************** a
DATA : lt_017 TYPE TABLE OF a017.
SELECT *
FROM a017
INTO TABLE lt_017
FOR ALL ENTRIES IN im_poitems
WHERE werks = im_req_params-werks
AND lifnr = im_poheader-vendor    "Vendor code
AND matnr = im_poitems-material   "Material number
AND ekorg = yss_cl_type_pool=>yss_c_rmss."purchasing org.

LOOP AT lt_017 ASSIGNING FIELD-SYMBOL(<lfs_017>).
IF sy-datum NOT BETWEEN <lfs_017>-datab AND <lfs_017>-datb
CLEAR <lfs_017>.
ENDIF.
ENDLOOP.
DELETE lt_017 WHERE kappl IS INITIAL AND kschl IS INITIAL.

CHECK lt_017 IS NOT INITIAL.

*get conditions from KONP
SELECT * FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_017
WHERE knumh = lt_017-knumh.
IF sy-subrc EQ 0.
SORT : lt_017 BY matnr,
lt_mat_price_po BY mat_id,
lt_konp BY knumh.
ENDIF.

LOOP AT lt_mat_price_po ASSIGNING FIELD-SYMBOL(<lfs_pr_po>).
READ TABLE lt_017 ASSIGNING <lfs_017> WITH KEY matnr = <lf
IF sy-subrc EQ 0.
READ TABLE lt_konp ASSIGNING FIELD-SYMBOL(<lfs_konp>) WI
IF <lfs_konp>-loevm_ko EQ abap_false.
<lfs_pr_po>-mat_price = <lfs_konp>-kbetr.
ELSE.
CONTINUE.
ENDIF.
ELSE.
APPEND INITIAL LINE TO lt_mat_prc ASSIGNING FIELD-SYMBOL
<lfs_mat_prc>-matnr =  <lfs_pr_po>-mat_id.
ENDIF.
ENDLOOP.

IF lt_mat_prc IS NOT INITIAL.
SELECT * FROM mbew INTO TABLE lt_mbew
FOR ALL ENTRIES IN lt_mat_prc
WHERE matnr = lt_mat_prc-matnr AND
bwkey = lv_werks.
IF sy-subrc EQ 0.
SORT lt_mbew BY matnr.
LOOP AT lt_mat_price_po ASSIGNING <lfs_price_po>.
READ TABLE lt_mbew ASSIGNING FIELD-SYMBOL(<lfs_mbew>)
WITH KEY matnr = <lfs_price_po>-mat_id BINARY SEARCH.
IF sy-subrc EQ 0.
IF <lfs_mbew>-vprsv EQ 'S'.
<lfs_price_po>-mat_price = <lfs_mbew>-stprs.
ENDIF.
IF <lfs_mbew>-vprsv EQ 'V'.
<lfs_price_po>-mat_price = <lfs_mbew>-verpr.
ENDIF.
ENDIF.
ENDLOOP.
ENDIF.
ENDIF.
********************************************************************** A
WHEN OTHERS.
SELECT SINGLE werks
FROM lfa1
INTO lv_werks
WHERE lifnr = ex_header-vendor.
*Get sales area data
SELECT SINGLE *
FROM t001w
INTO ls_t001w
WHERE werks = lv_werks.
*Get Customer number of vendor plant
SELECT SINGLE kunnr
FROM t001w
INTO lv_kunnr
WHERE werks = im_req_params-werks.
*Get price list
SELECT SINGLE pltyp
FROM knvv
INTO lv_pltyp
WHERE vkorg = ls_t001w-vkorg AND
vtweg = ls_t001w-vtweg AND
spart = ls_t001w-spart AND
kunnr = lv_kunnr.
*get material price
SELECT * FROM a701
INTO TABLE lt_a701
FOR ALL ENTRIES IN im_poitems
WHERE matnr = im_poitems-material AND
pltyp = lv_pltyp.
*delete records where current date does not lie between date range DATAB
LOOP AT lt_a701 ASSIGNING FIELD-SYMBOL(<lfs_a701>).
IF sy-datum NOT BETWEEN <lfs_a701>-datab AND <lfs_a701>-da
CLEAR <lfs_a701>.
ENDIF.
ENDLOOP.
DELETE lt_a701 WHERE kappl IS INITIAL AND kschl IS INITIAL.

CHECK lt_a701 IS NOT INITIAL.
*get conditions from KONP
SELECT * FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_a701
WHERE knumh = lt_a701-knumh.
IF sy-subrc EQ 0.
SORT : lt_a701 BY matnr,
lt_mat_price_po BY mat_id,
lt_konp BY knumh.
ENDIF.

LOOP AT lt_mat_price_po ASSIGNING <lfs_pr_po>.
READ TABLE lt_a701 ASSIGNING <lfs_a701> WITH KEY matnr = <
IF sy-subrc EQ 0.
READ TABLE lt_konp ASSIGNING <lfs_konp> WITH KEY knumh =
IF <lfs_konp>-loevm_ko EQ abap_false.
<lfs_pr_po>-mat_price = <lfs_konp>-kbetr.
ELSE.
CONTINUE.
ENDIF.
ELSE.
APPEND INITIAL LINE TO lt_mat_prc ASSIGNING <lfs_mat_prc
<lfs_mat_prc>-matnr =  <lfs_pr_po>-mat_id.
ENDIF.
ENDLOOP.

IF lt_mat_prc IS NOT INITIAL.
SELECT * FROM mbew INTO TABLE lt_mbew
FOR ALL ENTRIES IN lt_mat_prc
WHERE matnr = lt_mat_prc-matnr AND
bwkey = lv_werks.
IF sy-subrc EQ 0.
SORT lt_mbew BY matnr.
LOOP AT lt_mat_price_po ASSIGNING <lfs_price_po>.
READ TABLE lt_mbew ASSIGNING <lfs_mbew>
WITH KEY matnr = <lfs_price_po>-mat_id BINARY SEARCH.
IF sy-subrc EQ 0.
IF <lfs_mbew>-vprsv EQ 'S'.
<lfs_price_po>-mat_price = <lfs_mbew>-stprs.
ENDIF.
IF <lfs_mbew>-vprsv EQ 'V'.
<lfs_price_po>-mat_price = <lfs_mbew>-verpr.
ENDIF.
ENDIF.
ENDLOOP.
ENDIF.
ENDIF.

ENDCASE.
ELSE.
*----------------------for k* user-----------------------------*
CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = ex_header-ref_1
IMPORTING
output = lv_kunwe.

SELECT * FROM a817
INTO TABLE lt_817
FOR ALL ENTRIES IN lt_poitems
WHERE matnr = lt_poitems-material AND
kunwe = lv_kunwe AND
vtweg = yss_cl_type_pool=>yss_c_dh AND
kschl = yss_cl_type_pool=>yss_c_zpro.
IF sy-subrc EQ 0.
*get conditions from konp
SELECT * FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_817
WHERE knumh = lt_817-knumh.
IF sy-subrc EQ 0.
SORT : lt_817 BY matnr,
lt_mat_price_po BY mat_id,
lt_konp BY knumh.
ENDIF.
*delete records where current date does not lie between date range DATAB
LOOP AT lt_817 ASSIGNING FIELD-SYMBOL(<lfs_a817>).
IF sy-datum NOT BETWEEN <lfs_a817>-datab AND <lfs_a817>-datb
CLEAR <lfs_a817>.
ENDIF.
ENDLOOP.
DELETE lt_817 WHERE kappl IS INITIAL AND kschl IS INITIAL.

LOOP AT lt_mat_price_po ASSIGNING <lfs_pr_po>.
READ TABLE lt_817 ASSIGNING <lfs_a817> WITH KEY matnr = <lfs
IF sy-subrc EQ 0.
READ TABLE lt_konp ASSIGNING <lfs_konp> WITH KEY knumh = <
IF <lfs_konp>-loevm_ko EQ abap_false.
<lfs_pr_po>-mat_price = <lfs_konp>-kbetr.
ELSE.
CONTINUE.
ENDIF.
ELSE.
APPEND INITIAL LINE TO lt_mat_prc_2 ASSIGNING <lfs_mat_prc
<lfs_mat_prc>-matnr =  <lfs_pr_po>-mat_id.
ENDIF.
ENDLOOP.

IF lt_mat_prc IS NOT INITIAL.
SELECT * FROM mbew INTO TABLE lt_mbew
FOR ALL ENTRIES IN lt_mat_prc_2
WHERE matnr = lt_mat_prc_2-matnr AND
bwkey = lv_werks.
IF sy-subrc EQ 0.           ">>>>>>>>>>>>>>>>>>>>>>>>>>>
SORT lt_mbew BY matnr.
LOOP AT lt_mat_price_po ASSIGNING <lfs_price_po>.
READ TABLE lt_mbew ASSIGNING <lfs_mbew>
WITH KEY matnr = <lfs_price_po>-mat_id BINARY SEARCH.
IF sy-subrc EQ 0.
IF <lfs_mbew>-vprsv EQ 'S'.
<lfs_price_po>-mat_price = <lfs_mbew>-stprs.
ENDIF.
IF <lfs_mbew>-vprsv EQ 'V'.
<lfs_price_po>-mat_price = <lfs_mbew>-verpr.
ENDIF.
ENDIF.
ENDLOOP.

ENDIF.                       ">>>>>>>>>>>>>>>>>>>>>>>>>>>
ENDIF.
ENDIF.
ENDIF.
LOOP AT lt_mat_price_po ASSIGNING <lfs_price_po>.
lv_net_price = <lfs_price_po>-mat_quan * <lfs_price_po>-mat_pric
<lfs_price_po>-cgst_value = lv_net_price * ( <lfs_price_po>-cgst
<lfs_price_po>-igst_value = lv_net_price * ( <lfs_price_po>-igst
<lfs_price_po>-sgst_value = lv_net_price * ( <lfs_price_po>-sgst
<lfs_price_po>-net_price =  lv_net_price + <lfs_price_po>-cgst_v
ENDLOOP.
ch_item_mat_price = lt_mat_price_po.
ENDIF.

MOVE-CORRESPONDING lt_return TO ex_return.
ENDMETHOD.
FETCH_VENDOR_DETAILS
item
METHOD fetch_vendor_details.
DATA :  lt_address_keys TYPE  TABLE OF addr_key,
lt_adrc         TYPE  TABLE OF adrc,
lt_adrct        TYPE  TABLE OF adrct,
lt_adr2         TYPE  TABLE OF adr2,
lt_adr3         TYPE  TABLE OF adr3,
lt_adr4         TYPE  TABLE OF adr4,
lt_adr5         TYPE  TABLE OF adr5,
lt_adr6         TYPE  TABLE OF adr6,
lt_adr7         TYPE  TABLE OF adr7,
lt_adr8         TYPE  TABLE OF adr8,
lt_adr9         TYPE  TABLE OF adr9,
lt_adr10        TYPE  TABLE OF adr10,
lt_adr11        TYPE  TABLE OF adr11,
lt_adr12        TYPE  TABLE OF adr12,
lt_adr13        TYPE  TABLE OF adr13,
lt_adrt         TYPE  TABLE OF adrt,
ls_bapireturn   TYPE bapiret1,
lv_adrnr        TYPE adrnr,
lv_name         TYPE name1_gp.
*            lv_vendor       TYPE bapivendor_01-vendor_no.

*validate vendor Id
CALL FUNCTION 'BAPI_VENDOR_EXISTENCECHECK'
EXPORTING
vendorno = im_vendor
*       companycode = im_req_params-werks
IMPORTING
return   = ls_bapireturn.
IF ls_bapireturn-type = yss_cl_type_pool=>yss_c_e.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>vendor_not_found
msgv1  = ycx_ss_exception=>format( im_vendor )
msgv2  = ycx_ss_exception=>format( im_req_params-werks ).
ENDIF.
*Get adress number to pass in standard BAPI
SELECT SINGLE adrnr name1 FROM lfa1 INTO (lv_adrnr,lv_name) WHERE li
IF sy-subrc EQ 0.
ELSE.
RETURN.
ENDIF.
*Preparing import parameter table for standard RFC to get vendor address
APPEND INITIAL LINE TO lt_address_keys ASSIGNING FIELD-SYMBOL(<lfs_a
IF sy-subrc EQ 0.
<lfs_address_keys>-addrnumber = lv_adrnr.
ENDIF.

*get all address details for vendor
CALL FUNCTION 'ADDR1_EXTRACT_TABLES'
TABLES
t_address_keys = lt_address_keys
t_adrc         = lt_adrc
t_adrct        = lt_adrct
t_adr2         = lt_adr2
t_adr3         = lt_adr3
t_adr4         = lt_adr4
t_adr5         = lt_adr5
t_adr6         = lt_adr6
t_adr7         = lt_adr7
t_adr8         = lt_adr8
t_adr9         = lt_adr9
t_adr10        = lt_adr10
t_adr11        = lt_adr11
t_adr12        = lt_adr12
t_adr13        = lt_adr13
t_adrt         = lt_adrt
EXCEPTIONS
empty_table    = 1
OTHERS         = 2.
IF sy-subrc <> 0.
* Implement suitable error handling here
ENDIF.
READ TABLE lt_adrc ASSIGNING FIELD-SYMBOL(<lfs_adrc>) INDEX 1.
IF sy-subrc EQ 0.
ex_vendor_details-vendor_code = im_vendor.
ex_vendor_details-vendor_name =  <lfs_adrc>-name1.
ex_vendor_details-city        = <lfs_adrc>-city1.
ex_vendor_details-street      = <lfs_adrc>-street.
ex_vendor_details-country     = <lfs_adrc>-country.
ex_vendor_details-house_num   = <lfs_adrc>-house_num1.
ex_vendor_details-district    = <lfs_adrc>-city2.
ex_vendor_details-postal_code = <lfs_adrc>-post_code1.
ENDIF.
READ TABLE lt_adr2 ASSIGNING FIELD-SYMBOL(<lfs_adr2>) INDEX 1.
IF sy-subrc EQ 0.
ex_vendor_details-phone_num = <lfs_adr2>-tel_number.
ENDIF.
READ TABLE lt_adr6 ASSIGNING FIELD-SYMBOL(<lfs_adr6>) INDEX 1.
IF sy-subrc EQ 0.
ex_vendor_details-email_id = <lfs_adr6>-smtp_addr.
ENDIF.
ENDMETHOD.


FETCH_GOODS_RECEIPT_LIST
item
METHOD fetch_goods_receipt_list.
*----------------------------------------------------------------------*
*                    A D M I N I S T R A T I O N
*----------------------------------------------------------------------*
* Organization: Incresol Software Services Private Limited             *
* Created by  : Zareena Begum                                          *
* Created on  : 22-Mar-2018                                            *
* Description : To Fetch Goods Receipt List                            *
*----------------------------------------------------------------------*
*                       C H A N G E    L O G
*----------------------------------------------------------------------*
* <Changed by> | <Changed on> | <Change ID> like USERNAME.DDMMYY
* <Description of change>
*----------------------------------------------------------------------*
TYPES: BEGIN OF lty_mseg,
mblnr      TYPE mblnr,
mjahr      TYPE mjahr,
bwart      TYPE bwart,
budat_mkpf TYPE budat,
ebeln      TYPE bstnr,
ebelp      TYPE ebelp,
lfbnr      TYPE lfbnr,
lfpos      TYPE lfpos,
lifnr      TYPE elifn,
vbeln_im   TYPE vbeln_vl,
xblnr_mkpf TYPE xblnr,
END OF lty_mseg,
BEGIN OF lty_lfa1,
lifnr TYPE lifnr,
name1 TYPE name1_gp,
name2 TYPE name2_gp,
END OF lty_lfa1,
BEGIN OF lty_ekbe,
ebeln TYPE ebeln,
gjahr TYPE mjahr,
belnr TYPE mblnr,
bewtp TYPE bewtp,
END OF lty_ekbe,
BEGIN OF lty_po_list,
ebeln TYPE ebeln,
END OF lty_po_list .

DATA: lt_tvarvc    TYPE rsdsselopt_t,
lwa_tvarvc   TYPE LINE OF rsdsselopt_t,
lv_from_date TYPE sy-datum,
lt_r_date    TYPE yss_cl_type_pool=>yss_r_date,
lt_mseg      TYPE STANDARD TABLE OF lty_mseg,
lt_lfa1      TYPE STANDARD TABLE OF lty_lfa1,
lt_r_po      TYPE RANGE OF bstnr,
lt_r_vendor  TYPE RANGE OF lifnr,
lt_po_list   TYPE STANDARD TABLE OF lty_po_list,
lo_exception TYPE REF TO ycx_ss_exception,
lt_ekbe      TYPE TABLE OF lty_ekbe.

FIELD-SYMBOLS: <lfs_date>  TYPE LINE OF yss_cl_type_pool=>yss_r_date
CONSTANTS: lc_101 TYPE bwart VALUE '101',
lc_102 TYPE bwart VALUE '102',
lc_161 TYPE bwart VALUE '161'.

* To fill lt_r_date
IF im_date IS INITIAL.
*If im_date is initial, Get no. of days from TVARVC table
CALL METHOD yss_cl_util=>get_tvarvc_entries
EXPORTING
im_tvarvc_name = yss_cl_type_pool=>yss_c_gr_days
IMPORTING
ex_range       = lt_tvarvc.
READ TABLE lt_tvarvc INTO lwa_tvarvc INDEX 1.
IF sy-subrc EQ 0.
lv_from_date = sy-datum - lwa_tvarvc-low.
APPEND INITIAL LINE TO lt_r_date ASSIGNING <lfs_date>.
<lfs_date>-sign = 'I'.
<lfs_date>-option = 'BT'.
<lfs_date>-low = lv_from_date.
<lfs_date>-high = '99991231'."sy-datum.
ENDIF.
ELSEIF im_date-low IS NOT INITIAL AND im_date-high IS NOT INITIAL.
APPEND INITIAL LINE TO lt_r_date ASSIGNING <lfs_date>.
<lfs_date>-sign = 'I'.
<lfs_date>-option = 'BT'.
<lfs_date>-low = im_date-low.
<lfs_date>-high = im_date-high.
ELSEIF im_date-low IS NOT INITIAL AND im_date-high IS INITIAL.
APPEND INITIAL LINE TO lt_r_date ASSIGNING <lfs_date>.
<lfs_date>-sign = 'I'.
<lfs_date>-option = 'EQ'.
<lfs_date>-low = im_date-low.
ELSEIF im_date-low IS INITIAL AND im_date-high IS NOT INITIAL.
APPEND INITIAL LINE TO lt_r_date ASSIGNING <lfs_date>.
<lfs_date>-sign = 'I'.
<lfs_date>-option = 'EQ'.
<lfs_date>-low = im_date-high.
ENDIF.

*IF im_po_num is given
IF im_po_num IS NOT INITIAL.
APPEND INITIAL LINE TO lt_r_po ASSIGNING FIELD-SYMBOL(<lfs_po>).
<lfs_po>-sign = 'I'.
<lfs_po>-option = 'EQ'.
<lfs_po>-low = im_po_num.
ENDIF.

*If im_vendor is given
IF im_vendor IS NOT INITIAL.
APPEND INITIAL LINE TO lt_r_vendor ASSIGNING FIELD-SYMBOL(<lfs_ven
<lfs_vendor>-sign = 'I'.
<lfs_vendor>-option = 'EQ'.
<lfs_vendor>-low = im_vendor.
ENDIF.

* Fetch data from MSEG
SELECT mblnr
mjahr
bwart
budat_mkpf
ebeln
ebelp
lfbnr
lfpos
lifnr
vbeln_im
xblnr_mkpf FROM mseg
INTO TABLE lt_mseg
WHERE werks = im_req_params-werks AND
budat_mkpf IN lt_r_date AND       "CPUDT_MKPF
ebeln IN lt_r_po AND
lifnr IN lt_r_vendor AND
bwart IN (lc_101, lc_102,lc_161)              "1
ORDER BY cpudt_mkpf DESCENDING cputm_mkpf DESCENDING
%_HINTS ORACLE 'INDEX("MSEG" "MSEG~YSS")'.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>goods_rec_no_exist
msgv1  = ycx_ss_exception=>format( im_req_params-werks ).
ELSE.
*** >>> START GANGADHAR20180601 SORT  based on EBELN EBELP LFBNR and del
**      SORT lt_mseg BY ebeln ebelp mblnr DESCENDING bwart DESCENDING. "
SORT lt_mseg BY mblnr DESCENDING.
LOOP AT lt_mseg ASSIGNING FIELD-SYMBOL(<lfs_mseg_temp>).
AT NEW mblnr.
IF <lfs_mseg_temp>-bwart EQ '102'.
LOOP AT lt_mseg ASSIGNING FIELD-SYMBOL(<lfs_mmseg>) WHERE eb
mb
xb
DELETE lt_mseg.
ENDLOOP.
ENDIF.
ENDAT.
ENDLOOP.
*      DELETE ADJACENT DUPLICATES FROM lt_mseg COMPARING ebeln ebelp.

DELETE lt_mseg WHERE bwart EQ '102'.
*** <<< END GANGADHAR20180601
SORT lt_mseg BY mblnr mjahr.
DELETE ADJACENT DUPLICATES FROM lt_mseg COMPARING mblnr mjahr.
ENDIF.

*Fetch data from lfa1
IF lt_mseg IS NOT INITIAL.
SELECT lifnr
name1
name2 INTO TABLE lt_lfa1
FROM lfa1
FOR ALL ENTRIES IN lt_mseg
WHERE lifnr = lt_mseg-lifnr.
IF sy-subrc EQ 0.
"Do nothing
ENDIF.
***********************for purchase invoice number********************Ab
SELECT ebeln
gjahr
belnr
bewtp FROM ekbe INTO TABLE lt_ekbe FOR ALL ENTRIES IN lt_ms
*

IF sy-subrc EQ 0.
SORT lt_ekbe BY ebeln belnr DESCENDING.
DELETE ADJACENT DUPLICATES FROM lt_ekbe COMPARING ebeln.
SORT lt_ekbe BY ebeln.
ENDIF.
**********************************************************************
ENDIF.

*** >>> START GANGADHAR20180509
LOOP AT lt_mseg INTO DATA(ls_mseg).
APPEND INITIAL LINE TO lt_po_list ASSIGNING FIELD-SYMBOL(<lfs_po_l
<lfs_po_list>-ebeln = ls_mseg-ebeln.
ENDLOOP.

TRY.
CALL METHOD yss_cl_mm_process=>get_kad_code_n_name
EXPORTING
*           im_po_num    =
im_po_list   = lt_po_list
IMPORTING
ex_cust_list = ex_cust_list.
*        ex_cust_details =
CATCH ycx_ss_exception .
ENDTRY.

*** <<< END GANGADHAR20180509

*To get the data into ex_goods_receipt
LOOP AT lt_mseg ASSIGNING FIELD-SYMBOL(<lfs_mseg>).
APPEND INITIAL LINE TO ex_goods_receipt ASSIGNING FIELD-SYMBOL(<lf
<lfs_goods_receipt>-gr_num = <lfs_mseg>-mblnr.
IF <lfs_mseg>-bwart = lc_101.
<lfs_goods_receipt>-status = 'POSTED'.
ELSEIF <lfs_mseg>-bwart = lc_161.
<lfs_goods_receipt>-status = 'RETURN'.
*      ELSE.
*        <lfs_goods_receipt>-status = 'CANCELLED'.
ENDIF.
<lfs_goods_receipt>-gr_date = <lfs_mseg>-budat_mkpf.
<lfs_goods_receipt>-po_num = <lfs_mseg>-ebeln.
<lfs_goods_receipt>-vendor_num = <lfs_mseg>-lifnr.
<lfs_goods_receipt>-deliv_note = <lfs_mseg>-vbeln_im.   "newly add
READ TABLE lt_ekbe ASSIGNING FIELD-SYMBOL(<lfs_ekbe>) WITH KEY ebe
IF sy-subrc EQ 0.
<lfs_goods_receipt>-pur_inv_id = <lfs_ekbe>-belnr.    "newly add
ENDIF.
READ TABLE lt_lfa1 ASSIGNING FIELD-SYMBOL(<lfs_lfa1>) WITH KEY lif
IF sy-subrc EQ 0.
CONCATENATE <lfs_lfa1>-name1 <lfs_lfa1>-name2 INTO <lfs_goods_re
*        <lfs_goods_receipt>-vendor_name = <lfs_lfa1>-name1.
ENDIF.
*** >>> START GANGADHAR20180509
READ TABLE ex_cust_list INTO DATA(ls_cust_list) WITH KEY po_num =
IF sy-subrc EQ 0.
<lfs_goods_receipt>-cust_id   = ls_cust_list-cust_id.
<lfs_goods_receipt>-cust_name = ls_cust_list-cust_name.
ENDIF.

*** <<< END GANGADHAR20180509
ENDLOOP.



ENDMETHOD.
FETCH_MATERIAL_PRICE
item
method FETCH_MATERIAL_PRICE.
*    SELECT SINGLE PLTYP from knvv into lv_pltyp WHERE vwerk = im_req_pa
endmethod.
FETCH_PURCHASE_INVOICE_LIST
item
METHOD fetch_purchase_invoice_list.
TYPES : BEGIN OF lty_rbkp,
belnr  TYPE re_belnr,
gjahr  TYPE gjahr,
bldat  TYPE bldat,
budat  TYPE budat,
vgart  TYPE vgart,
lifnr  TYPE lifre,
rmwwr  TYPE rmwwr,
wmwst1 TYPE fwstev,
xrech  TYPE xrech,
stblg  TYPE stblg,
rbstat TYPE rbstat,
END OF lty_rbkp,
BEGIN OF lty_rseg,
belnr	TYPE belnr_d,
gjahr	TYPE gjahr,
buzei	TYPE rblgp,
ebeln TYPE ebeln,
wrbtr TYPE wrbtr,
xblnr	TYPE xblnr1,
END OF lty_rseg,
BEGIN OF lty_rseg_temp,
belnr	TYPE belnr_d,
gjahr	TYPE gjahr,
buzei	TYPE rblgp,
ebeln TYPE ebeln,
wrbtr TYPE wrbtr,
xblnr	TYPE vbeln_von,
END OF lty_rseg_temp,
BEGIN OF lty_po_list,
ebeln TYPE ebeln,
END OF lty_po_list,
BEGIN OF lty_lfa1,
lifnr TYPE lifnr,
name1 TYPE name1_gp,
name2 TYPE name2_gp,
END OF lty_lfa1,
BEGIN OF lty_vbfa,
vbelv   TYPE   vbeln_von,
posnv   TYPE   posnr_von,
vbeln   TYPE   vbeln_nach,
posnn   TYPE   posnr_nach,
vbtyp_n TYPE vbtyp_n,
END OF lty_vbfa.


DATA : lt_rbkp         TYPE TABLE OF lty_rbkp,
lt_rseg         TYPE TABLE OF lty_rseg,
lt_rseg_temp    TYPE TABLE OF lty_rseg_temp,
lt_po_list      TYPE STANDARD TABLE OF lty_po_list,
lt_cust_list    TYPE yss_tt_cust_list,
lt_lfa1         TYPE TABLE OF lty_lfa1,
lt_tab_value    TYPE TABLE OF dd07v,
lt_vbfa         TYPE TABLE OF lty_vbfa,
lr_posting_date TYPE RANGE OF budat.

TYPES: BEGIN OF lty_date_range,
sign(1)   TYPE c,
option(2) TYPE c,
low       TYPE budat,
high      TYPE  budat,
END   OF lty_date_range.

DATA: ls_date_range TYPE  lty_date_range,
lr_date_range TYPE  TABLE OF lty_date_range.
IF im_date_from IS NOT INITIAL AND im_date_to IS NOT INITIAL.
ls_date_range-sign = 'I'.
ls_date_range-option = 'BT'.
ls_date_range-low = im_date_from.
ls_date_range-high = im_date_to.
APPEND ls_date_range TO lr_date_range.
ENDIF.
*Document Header: Invoice Receipt

SELECT          belnr
gjahr
bldat
budat
vgart
lifnr
rmwwr
wmwst1
xrech
stblg
rbstat
FROM rbkp
INTO TABLE lt_rbkp
WHERE bukrs = yss_cl_type_pool=>yss_c_rmss      AND
budat IN lr_date_range                    AND
gsber = im_req_params-werks.
IF sy-subrc EQ 0.
*Document Item: Incoming Invoice
SELECT  belnr
gjahr
buzei
ebeln
wrbtr
xblnr
FROM rseg
INTO TABLE lt_rseg
FOR ALL ENTRIES IN lt_rbkp
WHERE belnr = lt_rbkp-belnr AND
gjahr = lt_rbkp-gjahr.
IF sy-subrc EQ 0.
SORT lt_rseg BY belnr gjahr.
LOOP AT lt_rseg INTO DATA(ls_rseg).   "+++GANGADHAR20180509
APPEND INITIAL LINE TO lt_po_list ASSIGNING FIELD-SYMBOL(<lfs_
<lfs_po_list>-ebeln = ls_rseg-ebeln.
ENDLOOP.

TRY.
CALL METHOD yss_cl_mm_process=>get_kad_code_n_name
EXPORTING
*               im_po_num    =
im_po_list   = lt_po_list
IMPORTING
ex_cust_list = lt_cust_list.
*        ex_cust_details =
CATCH ycx_ss_exception .
ENDTRY.
lt_rseg_temp = lt_rseg.
SELECT  vbelv
posnv
vbeln
posnn
vbtyp_n
FROM vbfa
INTO TABLE lt_vbfa
FOR ALL ENTRIES IN lt_rseg_temp
WHERE vbelv = lt_rseg_temp-xblnr AND vbtyp_n = '5'.
IF sy-subrc EQ 0.
SORT lt_vbfa BY vbelv.
DELETE ADJACENT DUPLICATES FROM lt_vbfa COMPARING vbelv.
SORT lt_vbfa BY vbelv.
ENDIF.
ENDIF.
*Vendor name
SELECT lifnr
name1
name2
FROM lfa1
INTO TABLE lt_lfa1
FOR ALL ENTRIES IN lt_rbkp
WHERE lifnr = lt_rbkp-lifnr.
IF sy-subrc EQ 0.
SORT lt_lfa1 BY lifnr.
ENDIF.
ELSE.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>no_invoice_found
msgv1  = ycx_ss_exception=>format( im_req_params-werks ).
ENDIF.
*Reading the domain(RBSTAT) fixed values
CALL FUNCTION 'DD_DOMVALUES_GET'
EXPORTING
text      = abap_true
domname   = 'RBSTAT'
langu     = yss_cl_type_pool=>yss_c_e
TABLES
dd07v_tab = lt_tab_value.
IF sy-subrc EQ 0.
SORT lt_tab_value BY domvalue_l.
ENDIF.

LOOP AT lt_rbkp ASSIGNING FIELD-SYMBOL(<lfs_rbkp>).
IF <lfs_rbkp>-stblg IS NOT INITIAL AND im_report_flag EQ abap_fals
CONTINUE.
ENDIF.
APPEND INITIAL LINE TO ex_purchase_inv_list ASSIGNING FIELD-SYMBOL
<lfs_pur_inv_list>-inv_id   = <lfs_rbkp>-belnr.     "Accounting Do
<lfs_pur_inv_list>-inv_date = <lfs_rbkp>-budat.     "Invoice posti
<lfs_pur_inv_list>-amount   = <lfs_rbkp>-rmwwr.     "Gross invoice
<lfs_pur_inv_list>-fiscal_year = <lfs_rbkp>-gjahr.  "Fiscal year
<lfs_pur_inv_list>-base_amount = <lfs_rbkp>-rmwwr - <lfs_rbkp>-wmw

*<<<<<<<< "++++Start Abbhshek 07/06/2018
IF <lfs_rbkp>-xrech EQ abap_true.
<lfs_pur_inv_list>-trans_type = 'Invoice'(013).
ELSE.
<lfs_pur_inv_list>-trans_type = 'Credit Memo'(014).
ENDIF.
*"++++Abhishek End 07/06/2018 >>>>>>>>>>

READ TABLE lt_lfa1 ASSIGNING FIELD-SYMBOL(<lfs_lfa1>) WITH KEY lif
IF sy-subrc EQ 0.
CONCATENATE <lfs_lfa1>-name1 <lfs_lfa1>-name2 INTO  <lfs_pur_inv
<lfs_pur_inv_list>-vendor_id = <lfs_lfa1>-lifnr.
ENDIF.
READ TABLE lt_rseg ASSIGNING FIELD-SYMBOL(<lfs_rseg>) WITH KEY bel
IF sy-subrc EQ 0.
<lfs_pur_inv_list>-gi_no =  <lfs_rseg>-xblnr. "Reference Documen
<lfs_pur_inv_list>-po_num = <lfs_rseg>-ebeln. "Purchasing Docume

* Read the KAD cust id and name
READ TABLE lt_cust_list INTO DATA(ls_cust_list) WITH KEY po_num
IF sy-subrc EQ 0.
<lfs_pur_inv_list>-cust_id   = ls_cust_list-cust_id.
<lfs_pur_inv_list>-cust_name = ls_cust_list-cust_name.
ENDIF.
READ TABLE lt_vbfa ASSIGNING FIELD-SYMBOL(<lfs_vbfa>) WITH KEY v
IF sy-subrc EQ 0.
<lfs_pur_inv_list>-billing_doc = <lfs_vbfa>-vbeln.
ENDIF.
ENDIF.
IF <lfs_rbkp>-stblg IS NOT INITIAL.
IF <lfs_rbkp>-vgart EQ yss_cl_type_pool=>yss_c_vgart_rs.  "Trans
CONCATENATE 'Cancellation of'(003) <lfs_rbkp>-stblg INTO <lfs_
CONTINUE.
ELSEIF <lfs_rbkp>-vgart EQ yss_cl_type_pool=>yss_c_vgart_rd.
CONCATENATE 'Cancelled by'(004) <lfs_rbkp>-stblg INTO <lfs_pur
CONTINUE.
ENDIF.
ENDIF.

READ TABLE lt_tab_value ASSIGNING FIELD-SYMBOL(<lfs_tab_value>) WI
IF sy-subrc EQ 0.
CASE <lfs_rbkp>-rbstat.
WHEN '5'.
<lfs_pur_inv_list>-status = 'Generated Invoice'(002).
WHEN OTHERS.
<lfs_pur_inv_list>-status = <lfs_tab_value>-ddtext.
ENDCASE.
ENDIF.
ENDLOOP.
ENDMETHOD.
FETCH_PURCHASE_INV_DETAILS
item
METHOD fetch_purchase_inv_details.
TYPES:
BEGIN OF lty_rseg,
belnr         TYPE belnr_d,
gjahr         TYPE gjahr,
buzei         TYPE rblgp,
matnr         TYPE matnr,
werks         TYPE werks_d,
stock_posting TYPE stock_posting,
END OF lty_rseg,

BEGIN OF lty_vbfa,
vbelv   TYPE vbfa-vbelv,
posnv   TYPE vbfa-posnv,
vbeln   TYPE vbfa-vbeln,
posnn   TYPE vbfa-posnn,
vbtyp_n TYPE vbfa-vbtyp_n,
vbtyp_v TYPE vbfa-vbtyp_v,
erdat	  TYPE erdat,      "++sapabap.03122018
END OF lty_vbfa,

BEGIN OF lty_vbrk,
vbeln TYPE vbrk-vbeln,
knumv TYPE vbrk-knumv,
netwr TYPE vbrk-netwr,
END OF lty_vbrk,

BEGIN OF lty_konv,
knumv TYPE konv-knumv,
kposn TYPE konv-kposn,
kschl TYPE konv-kschl,
kbetr TYPE konv-kbetr,
kwert TYPE konv-kwert,
END OF lty_konv,

BEGIN OF lty_vbrp,
vbeln TYPE vbrp-vbeln,
posnr TYPE vbrp-posnr,
fkimg TYPE vbrp-fkimg,
meins TYPE vbrp-meins,
netwr TYPE vbrp-netwr,
vgbel TYPE vbrp-vgbel,
vgpos TYPE vbrp-vgpos,
aubel TYPE vbrp-aubel,
aupos TYPE vbrp-aupos,
END OF lty_vbrp,

BEGIN OF lty_mkpf,
mblnr TYPE mblnr,
mjahr TYPE mjahr,
bldat TYPE bldat,
END OF lty_mkpf,

BEGIN OF lty_likp,
vbeln TYPE vbeln_vl,
bldat TYPE bldat,
END OF lty_likp,

BEGIN OF lty_mseg,
mblnr TYPE mblnr,
mjahr TYPE mjahr,
zeile TYPE mblpo,
charg TYPE charg_d,
END OF lty_mseg,

BEGIN OF lty_marc,
matnr TYPE marc-matnr,
werks TYPE marc-werks,
steuc TYPE marc-steuc,
END OF lty_marc,
BEGIN OF lty_ekpo,
ebeln TYPE  ebeln,
ebelp TYPE ebelp,
menge TYPE bstmg,
END OF lty_ekpo,
BEGIN OF lty_ekko,
ebeln TYPE ebeln,
END OF lty_ekko.

DATA :
lt_ekpo       TYPE TABLE OF lty_ekpo,
lt_ekko       TYPE TABLE OF lty_ekko,
lt_vbfa       TYPE TABLE OF lty_vbfa,
lt_vbrk       TYPE TABLE OF lty_vbrk,
lt_mseg       TYPE TABLE OF lty_mseg,
lt_konv       TYPE TABLE OF lty_konv,
lt_vbrp       TYPE TABLE OF lty_vbrp,
lt_rtax1u15   TYPE TABLE OF rtax1u15,
lt_condtype   TYPE TABLE OF rtax1u15,
lt_rseg       TYPE TABLE OF lty_rseg,
lt_marc       TYPE TABLE OF lty_marc,
lt_mkpf       TYPE STANDARD TABLE OF lty_mkpf,
lt_likp       TYPE STANDARD TABLE OF lty_likp,
lv_ebeln      TYPE ebeln,
ls_vbfa       TYPE lty_vbfa,
ls_vbrk       TYPE lty_vbrk,
ls_mseg       TYPE lty_mseg,
lv_mseg_price TYPE mseg-dmbtr,
ls_konv       TYPE lty_konv,
ls_vbrp       TYPE lty_vbrp,
lv_lifnr      TYPE elifn,
lv_konv_price TYPE konv-kwert,
lv_gjahr      TYPE gjahr,
lv_bukrs      TYPE bkpf-bukrs VALUE 'RMSS',
lv_taxcode    TYPE bseg-mwskz,
lv_unit       TYPE bkpf-waers,
lv_wrbtr      TYPE bseg-wrbtr,
lt_mat        TYPE yss_tt_mat.


*Get Fiscal Year For Invoice Document to fetch item details
SELECT SINGLE MAX( gjahr )
FROM rbkp
INTO lv_gjahr
WHERE belnr = im_inv_id.
IF sy-subrc EQ 0.
*Fetch Item Details
SELECT belnr
gjahr
buzei
matnr
werks
stock_posting
FROM rseg
INTO TABLE lt_rseg
WHERE belnr = im_inv_id AND
gjahr = lv_gjahr AND
werks = im_req_params-werks.
IF sy-subrc EQ 0.
SORT lt_rseg BY belnr gjahr buzei.
ENDIF.
ENDIF.

*Get Details For Incoming Invoice Based On Invoice Id
CALL FUNCTION 'BAPI_INCOMINGINVOICE_GETDETAIL'
EXPORTING
invoicedocnumber = im_inv_id              "Invoice Id
fiscalyear       = lv_gjahr               "Fiscal year
IMPORTING
headerdata       = ex_headerdata           "Header details
addressdata      = ex_addressdata
TABLES
itemdata         = ex_itemdata             "Item details
return           = ex_return.

****** >>> START GANGADHAR20180509
* Fetch KAD Code and Username
READ TABLE ex_itemdata INTO DATA(ls_itemdata) INDEX 1.
IF sy-subrc EQ 0.
TRY.
CALL METHOD get_kad_code_n_name
EXPORTING
im_po_num       = ls_itemdata-po_number
IMPORTING
ex_cust_details = ex_cust_details.
CATCH ycx_ss_exception .
ENDTRY.
*Get vendor related details(name,ID)
SELECT SINGLE lifnr FROM ekko
INTO lv_lifnr WHERE ebeln = ls_itemdata-po_number.
IF sy-subrc EQ 0.
CALL METHOD yss_cl_mm_process=>fetch_vendor_details
EXPORTING
im_req_params     = im_req_params
im_vendor         = lv_lifnr
IMPORTING
ex_vendor_details = ex_vendor_details.
ENDIF.
ENDIF.
****** <<< END GANGADHAR20180509
DATA(lt_rseg_makt) = lt_rseg.
SORT lt_rseg_makt BY matnr.
DELETE ADJACENT DUPLICATES FROM lt_rseg_makt COMPARING matnr.
*get material text
IF lt_rseg_makt IS NOT INITIAL.
SELECT matnr
maktx
FROM makt
INTO TABLE lt_mat
FOR ALL ENTRIES IN lt_rseg_makt
WHERE matnr = lt_rseg_makt-matnr.
IF sy-subrc EQ 0.
SORT lt_mat BY mat_num.
ENDIF.
ENDIF.
*Added on 25/07/2018 Abhishek start+++
DATA(lt_rseg_marc) = lt_rseg.
SORT lt_rseg_marc BY matnr.

IF lt_rseg_marc IS NOT INITIAL.
SELECT matnr
werks
steuc
FROM marc
INTO TABLE lt_marc
FOR ALL ENTRIES IN lt_rseg_marc
WHERE matnr = lt_rseg_marc-matnr
AND werks = im_req_params-werks.
IF sy-subrc EQ 0.
SORT lt_marc BY matnr.
ENDIF.
ENDIF.
*Abhishek End+++

* Fetch GR date from Material Document/GR header
SELECT mblnr
mjahr
bldat
FROM mkpf
INTO TABLE lt_mkpf
FOR ALL ENTRIES IN ex_itemdata
WHERE mblnr EQ ex_itemdata-ref_doc
AND mjahr EQ ex_itemdata-ref_doc_year.
IF sy-subrc EQ 0.
SORT lt_mkpf BY mblnr.
ENDIF.

* Fetch the Batch number from Material Document/GR item table
IF ex_itemdata IS NOT INITIAL.
*  fetch delivery date from delivery header table
SELECT vbeln
bldat
FROM likp
INTO TABLE lt_likp
FOR ALL ENTRIES IN ex_itemdata
WHERE vbeln EQ ex_itemdata-ref_doc_no(10).
IF sy-subrc EQ 0.
SORT lt_likp BY vbeln.
ENDIF.

SELECT mblnr
mjahr
zeile
charg
FROM mseg
INTO TABLE lt_mseg
FOR ALL ENTRIES IN ex_itemdata
WHERE mblnr EQ ex_itemdata-ref_doc
AND mjahr EQ ex_itemdata-ref_doc_year
AND zeile EQ ex_itemdata-ref_doc_it.
IF sy-subrc EQ 0.
SORT lt_mseg BY mblnr mjahr zeile.
ENDIF.

*For Price Difference Logic get data from sales document flow table
SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
erdat                     "Date on Which Record Was Created
FROM vbfa
INTO TABLE lt_vbfa
WHERE vbelv = im_delivery_no
AND   vbtyp_v IN ( yss_cl_type_pool=>yss_c_j, yss_cl_type_p
AND   fktyp  = yss_cl_type_pool=>yss_c_i.
IF sy-subrc = 0.
*Fetch data(eg : price) from Billing header
SELECT vbeln
knumv
netwr
FROM vbrk
INTO TABLE lt_vbrk
FOR ALL ENTRIES IN lt_vbfa
WHERE vbeln = lt_vbfa-vbeln AND
fksto NE abap_true.
IF lt_vbrk IS NOT INITIAL.
*Billing item table
SELECT vbeln
posnr
fkimg
meins
netwr
vgbel
vgpos
aubel
aupos
FROM vbrp
INTO TABLE lt_vbrp
FOR ALL ENTRIES IN lt_vbrk
WHERE vbeln = lt_vbrk-vbeln.
IF sy-subrc = 0.
SORT lt_vbrp BY vbeln posnr.
ENDIF.
*Get tax amounts from Conditions table
SELECT knumv
kposn
kschl
kbetr
kwert
FROM konv
INTO TABLE lt_konv
FOR ALL ENTRIES IN lt_vbrk
WHERE knumv = lt_vbrk-knumv
AND   kschl IN ('ZSPE','ZSVL','ZPER','ZVAL','ZPRO').
IF sy-subrc = 0.
SORT lt_konv BY knumv kposn.
ENDIF.
ENDIF.
ENDIF.
SORT lt_vbrk BY vbeln DESCENDING.
READ TABLE lt_vbrk INTO ls_vbrk INDEX 1.
IF sy-subrc = 0.
"Do Nothing
ENDIF.
ENDIF.

*prepare final item table for given Invoice Id
LOOP AT ex_itemdata ASSIGNING FIELD-SYMBOL(<lfs_taxicondtem1>).
lv_taxcode = <lfs_taxicondtem1>-tax_code.   "Tax code
lv_unit    = <lfs_taxicondtem1>-po_unit.    "po unit
*Get Tax Condition Type Based On Tax Code
CALL FUNCTION 'CALCULATE_TAX_FROM_NET_AMOUNT'
EXPORTING
i_bukrs = lv_bukrs         "Company code
i_mwskz = lv_taxcode       "tax code
i_waers = lv_unit          "unit
i_wrbtr = lv_wrbtr         "price
TABLES
t_mwdat = lt_rtax1u15.
DELETE lt_rtax1u15 WHERE kschl <> yss_cl_type_pool=>yss_c_jicg AND
kschl <> yss_cl_type_pool=>yss_c_jisg AND
kschl <> yss_cl_type_pool=>yss_c_jiig .
APPEND INITIAL LINE TO ex_item_details ASSIGNING FIELD-SYMBOL(<lfs
<lfs_item_details>-gi_no      = <lfs_taxicondtem1>-ref_doc.     "D
<lfs_item_details>-uom        = <lfs_taxicondtem1>-po_unit_iso.
<lfs_item_details>-item_no    = <lfs_taxicondtem1>-invoice_doc_ite
<lfs_item_details>-qty        = <lfs_taxicondtem1>-quantity.
<lfs_item_details>-actual_qty = <lfs_taxicondtem1>-quantity.
<lfs_item_details>-net_price  = <lfs_taxicondtem1>-item_amount.
<lfs_item_details>-po_number  = <lfs_taxicondtem1>-po_number.
<lfs_item_details>-po_item    = <lfs_taxicondtem1>-po_item.
<lfs_item_details>-del_note   = <lfs_taxicondtem1>-ref_doc_no.
*Batch
READ TABLE lt_mseg INTO ls_mseg WITH KEY mblnr = <lfs_taxicondtem1
mjahr = <lfs_taxicondtem1
zeile = <lfs_taxicondtem1
IF sy-subrc EQ 0.
<lfs_item_details>-batch    = ls_mseg-charg.
ENDIF.
*GR Date
READ TABLE lt_mkpf INTO DATA(ls_mkpf) WITH KEY mblnr = <lfs_item_d
IF sy-subrc EQ 0.
<lfs_item_details>-gr_date = ls_mkpf-bldat.
ENDIF.
*Delivery date
READ TABLE lt_likp INTO DATA(ls_likp) WITH KEY vbeln = <lfs_item_d
IF sy-subrc EQ 0.
<lfs_item_details>-dlv_date = ls_likp-bldat.
ENDIF.
*Condition type & TAX rate
LOOP AT lt_rtax1u15 ASSIGNING FIELD-SYMBOL(<lfs_rtax>).
<lfs_item_details>-cond_type = <lfs_rtax>-kschl.
<lfs_item_details>-tax_rate  = <lfs_rtax>-msatz.
*CGST rate
IF <lfs_rtax>-kschl EQ yss_cl_type_pool=>yss_c_jicg.
<lfs_item_details>-cgst_rate = <lfs_rtax>-msatz.
ENDIF.
*SGST rate
IF <lfs_rtax>-kschl EQ yss_cl_type_pool=>yss_c_jisg.
<lfs_item_details>-sgst_rate = <lfs_rtax>-msatz.
ENDIF.
*IGST rate
IF <lfs_rtax>-kschl EQ yss_cl_type_pool=>yss_c_jiig.
<lfs_item_details>-igst_rate = <lfs_rtax>-msatz.
ENDIF.
ENDLOOP.
*Material Id
READ TABLE lt_rseg ASSIGNING FIELD-SYMBOL(<lfs_rseg>) WITH KEY bel
gjahr = l
buzei = <
IF sy-subrc EQ 0.
<lfs_item_details>-mat_id = <lfs_rseg>-matnr.
READ TABLE lt_mat ASSIGNING FIELD-SYMBOL(<lfs_mat>)
WITH KEY mat_num = <lfs_rseg>-matnr BINARY SEARCH.
IF sy-subrc EQ 0.
<lfs_item_details>-mat_desc = <lfs_mat>-mat_name.
ENDIF.
READ TABLE lt_marc ASSIGNING FIELD-SYMBOL(<lfs_marc>)
WITH KEY matnr = <lfs_rseg>-matnr BINARY SEARCH.
IF sy-subrc EQ 0.
<lfs_item_details>-hsn_code = <lfs_marc>-steuc.
ENDIF.
**** For Discount and Price difference +++ABHISHEK15112018 >>>
*discount
<lfs_item_details>-discount   = <lfs_rseg>-stock_posting.
*gross price/base value
<lfs_item_details>-base_price = ( -1 * <lfs_item_details>-discou
*unit price
<lfs_item_details>-unit_price = <lfs_item_details>-base_price /
*price difference
ex_price_difference = ex_price_difference + <lfs_item_details>-d
****** <<< END ABHISHEK15112018

**start Abhishek 22/11/2018
*unit price without discount
<lfs_item_details>-unit_price_wo_discount =  <lfs_taxicondtem1>-
READ TABLE lt_vbfa ASSIGNING FIELD-SYMBOL(<lfs_vbfa>) WITH KEY v
IF sy-subrc EQ 0.
<lfs_item_details>-vendor_invoice = <lfs_vbfa>-vbeln.
move:
<lfs_vbfa>-erdat to <lfs_item_details>-bill_date.     "++sap
ENDIF.
**end Abhishek  22/11/2018
ENDIF.
*IGST/CGST/SGST value calculation
<lfs_item_details>-cgst_value = <lfs_item_details>-net_price * ( <
<lfs_item_details>-igst_value = <lfs_item_details>-net_price * ( <
<lfs_item_details>-sgst_value = <lfs_item_details>-net_price * ( <
<lfs_item_details>-tot_price  =  <lfs_item_details>-net_price + <l
<l
<l
**** For Discount and Price difference +++GANGADHAR20180531 >>>
***      READ TABLE lt_vbrp INTO DATA(lwa_vbrp) WITH KEY aubel = <lfs_ta
***                                                      aupos = <lfs_ta
***      IF sy-subrc EQ 0.
***        READ TABLE lt_konv WITH KEY knumv = ls_vbrk-knumv
***                                    kposn = lwa_vbrp-posnr TRANSPORTI
***        IF sy-subrc EQ 0.
***          DATA(lv_index) = sy-tabix.
***          LOOP AT lt_konv INTO ls_konv FROM lv_index.
***            IF ls_konv-knumv NE ls_vbrk-knumv OR ls_konv-kposn NE lwa
***              EXIT.
***            ENDIF.
****BASE price determination
***            CASE ls_konv-kschl.
***              WHEN 'ZPRO'.
***                <lfs_item_details>-base_price = ls_konv-kwert.
****UNIT price
***                <lfs_item_details>-unit_price = ls_konv-kbetr.
***              WHEN 'ZPER' OR 'ZVAL' OR 'ZSPE' OR 'ZSVL'.
****Discount value
***                <lfs_item_details>-discount   = <lfs_item_details>-di
****price difference
***                ex_price_difference = ex_price_difference + ls_konv-k
***              WHEN OTHERS.
***            ENDCASE.
***          ENDLOOP.
***        ENDIF.
***      ENDIF.
****** <<< END GANGADHAR20180531
ENDLOOP.

IF im_po_flag EQ abap_true.
SELECT    ebeln
FROM ekko
INTO TABLE lt_ekko
WHERE unsez = im_inv_id.
IF sy-subrc EQ 0.
SELECT ebeln
ebelp
menge
FROM ekpo
INTO TABLE lt_ekpo
FOR ALL ENTRIES IN lt_ekko
WHERE ebeln = lt_ekko-ebeln.
SORT lt_ekpo BY ebelp.
IF sy-subrc EQ 0.
LOOP AT ex_item_details ASSIGNING <lfs_item_details>.
<lfs_item_details>-actual_qty = <lfs_item_details>-qty.
LOOP AT lt_ekpo ASSIGNING FIELD-SYMBOL(<lfs_ekpo>) WHERE ebe
<lfs_item_details>-qty = <lfs_item_details>-qty - <lfs_ekp
ENDLOOP.
ENDLOOP.
ENDIF.
ENDIF.
DELETE ex_item_details WHERE qty IS INITIAL.
ENDIF.
ENDMETHOD.
CREATE_GOODS_RECEIPT
item
METHOD create_goods_receipt.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Incresol Software Services Pvt. Ltd.
* Created on  : 28-March-2018
* Description : Create Goods Receipt w.r.t Outbound Delivery
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*

*TYPES declarations
TYPES : BEGIN OF lty_lips,
vbeln TYPE lips-vbeln,
posnr TYPE lips-posnr,
matnr TYPE lips-matnr,
werks TYPE lips-werks,
lgort TYPE lips-lgort,
charg TYPE lips-charg,
lfimg TYPE lips-lfimg,
vrkme TYPE lips-vrkme,
vgbel TYPE lips-vgbel,
vgpos TYPE lips-vgpos,
END OF lty_lips.

TYPES : BEGIN OF lty_ekpo,
ebeln TYPE ekpo-ebeln,
ebelp TYPE ekpo-ebelp,
matnr TYPE ekpo-matnr,
bukrs TYPE ekpo-bukrs,
werks TYPE ekpo-werks,
lgort TYPE ekpo-lgort,
menge	TYPE bstmg,      "Added by Abhishek 06/07/2018
meins	TYPE bstme,      "Added by Abhishek 06/07/2018
END OF lty_ekpo.
*** >>>  START GANGADHAR20180614
TYPES: BEGIN OF lty_mseg,
mblnr      TYPE mblnr,
mjahr      TYPE mjahr,
zeile      TYPE mblpo,
bwart      TYPE bwart,
ebeln      TYPE bstnr,
ebelp      TYPE ebelp,
lfbnr      TYPE lfbnr,
xblnr_mkpf TYPE xblnr,
END OF lty_mseg,
BEGIN OF lty_vbup,
vbeln TYPE vbeln,
posnr TYPE posnr,
wbsta TYPE wbsta,
uvvlk TYPE uvvlk_up,
uvpik TYPE uvpip_up,
END OF lty_vbup.


DATA: lt_mseg TYPE STANDARD TABLE OF lty_mseg.
*** <<< END GANGADHAR20180614

*Data Declarations
DATA : lt_lips            TYPE TABLE OF lty_lips,
lt_ekpo            TYPE TABLE OF lty_ekpo,
lt_goodsmvt_item   TYPE TABLE OF bapi2017_gm_item_create,
lt_return          TYPE TABLE OF bapiret2,
ls_lips            TYPE lty_lips,
ls_ekpo            TYPE lty_ekpo,
ls_goodsmvt_header TYPE bapi2017_gm_head_01,
lt_vbup            TYPE TABLE OF lty_vbup,
ls_goodsmvt_item   TYPE bapi2017_gm_item_create,
lv_goodsmvt_code   TYPE bapi2017_gm_code,
lv_gr_date         TYPE bldat,
ls_return          TYPE bapiret2,
lv_mat_doc         TYPE bapi2017_gm_head_ret-mat_doc,
lv_year            TYPE bapi2017_gm_head_ret-doc_year,
lv_vbeln           TYPE likp-vbeln.

IF im_vbeln IS NOT INITIAL.   "Added by Abhishek ++++ 05/07/2018   f
*Add Leading Zero's
CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = im_vbeln
IMPORTING
output = lv_vbeln.

*** >>> START GANGADHAR20180614
**** Check already GR created or not for the corresponding delivery numb
***    SELECT SINGLE mblnr FROM mkpf INTO @DATA(lv_mblnr)
***      WHERE xblnr EQ @lv_vbeln
***        AND blart EQ 'WE'.
***    IF sy-subrc EQ 0.
***      RAISE EXCEPTION TYPE ycx_ss_exception
***        EXPORTING
***          textid = ycx_ss_exception=>gr_already_created
***          msgv1  = ycx_ss_exception=>format( lv_vbeln ).
***    ENDIF.
*** <<< END GANGADHAR20180614
*Get Delivery Details
*--------------------------------------------------------------------*
SELECT  vbeln
posnr
wbsta
uvvlk
uvpik INTO TABLE lt_vbup FROM vbup WHERE vbeln = lv_vbeln
wbsta = yss_cl_ty
uvvlk = yss_cl_ty
uvpik = yss_cl_ty
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>goods_not_delivered.
ENDIF.

*--------------------------------------------------------------------*
SELECT vbeln
posnr
matnr
werks
lgort
charg
lfimg
vrkme
vgbel
vgpos
FROM lips
INTO TABLE lt_lips
WHERE vbeln = lv_vbeln.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.
SORT lt_lips BY vbeln posnr.

*Get Plant for the PO
SELECT ebeln
ebelp
matnr
bukrs
werks
lgort
FROM ekpo
INTO TABLE lt_ekpo
FOR ALL ENTRIES IN lt_lips
WHERE ebeln = lt_lips-vgbel.
IF sy-subrc = 0.
SORT lt_ekpo BY ebeln ebelp.
*** >>> START GANGADHAR20180614
**** Check already GR created or not for the corresponding delivery numb
SELECT mblnr mjahr zeile bwart ebeln ebelp lfbnr xblnr_mkpf
INTO TABLE lt_mseg FROM mseg
FOR ALL ENTRIES IN lt_ekpo
WHERE ebeln EQ lt_ekpo-ebeln
AND ebelp EQ lt_ekpo-ebelp
AND bwart IN ('101','102')
AND xblnr_mkpf EQ lv_vbeln.
IF sy-subrc EQ 0.
*          SORT lt_mseg BY xblnr_mkpf lfbnr bwart DESCENDING .
SORT lt_mseg BY xblnr_mkpf bwart DESCENDING.
DELETE ADJACENT DUPLICATES FROM lt_mseg COMPARING xblnr_mkpf.
DELETE lt_mseg WHERE bwart EQ '102'.
IF lt_mseg IS NOT INITIAL.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>gr_already_created
msgv1  = ycx_ss_exception=>format( lv_vbeln ).
ENDIF.
ENDIF.
*** <<< END GANGADHAR20180614
ENDIF.

***Header Data for Goods Receipts
*      IF im_gr_date IS INITIAL.
*        lv_gr_date = sy-datum.
*      ELSE.
*        lv_gr_date = im_gr_date.
*      ENDIF.
*
ls_goodsmvt_header-pstng_date = im_posting_date.   "sy-datum.
ls_goodsmvt_header-doc_date   = im_gr_date.        "sy-datum.
ls_goodsmvt_header-ref_doc_no = lv_vbeln.          "The outbound d
ls_goodsmvt_header-header_txt = im_header_text.    "Any comments B
lv_goodsmvt_code = '01'.                           "(Documentation
" but it is val

*Item Level Plant
READ TABLE lt_ekpo INTO ls_ekpo INDEX 1.
IF sy-subrc = 0.
" Do Nothing
ENDIF.
***The following code repeats for each line of the Outbound Delivery to
LOOP AT lt_lips INTO ls_lips WHERE lfimg IS NOT INITIAL.
ls_goodsmvt_item-move_type  = '101'.            "movement TYPE
ls_goodsmvt_item-deliv_numb = ls_lips-vbeln.    "delivery NUMBER
ls_goodsmvt_item-deliv_item = ls_lips-posnr.    "delivery LINE i
ls_goodsmvt_item-material   = ls_lips-matnr.    "material number
ls_goodsmvt_item-plant      = ls_ekpo-werks.    "receiving site.
ls_goodsmvt_item-stge_loc   = 'KS01'.           "receiving STORA
ls_goodsmvt_item-entry_qnt  = ls_lips-lfimg.    "quantity
ls_goodsmvt_item-entry_uom  = ls_lips-vrkme.    "unit OF measure
ls_goodsmvt_item-po_number  = ls_lips-vgbel.
ls_goodsmvt_item-po_item    = ls_lips-vgpos.
ls_goodsmvt_item-batch      = ls_lips-charg.
*  ls_goodsmvt_item-no_more_gr = 'X'.                   "(if no further
ls_goodsmvt_item-mvt_ind    = 'B'.              "(represents gr
APPEND ls_goodsmvt_item TO lt_goodsmvt_item.
CLEAR : ls_lips,ls_goodsmvt_item.
ENDLOOP.
ELSE.

******Below  else part is for "create Goods Receipt using purchase order
**********************************************************************
***Header Data for Goods Receipts
*      IF im_gr_date IS INITIAL.
*        lv_gr_date = sy-datum.
*      ELSE.
*        lv_gr_date = im_gr_date.
*      ENDIF.
ls_goodsmvt_header-pstng_date = im_posting_date.   "Posting date (
ls_goodsmvt_header-doc_date   = im_gr_date.        "Document date
ls_goodsmvt_header-ref_doc_no = im_ebeln.          "The purchase o
ls_goodsmvt_header-header_txt = im_header_text.    "Any comments B
lv_goodsmvt_code = '01'.                           "(Documentation

*Get Plant for the PO
SELECT ebeln
ebelp
matnr
bukrs
werks
lgort
menge
meins
FROM ekpo
INTO TABLE lt_ekpo
WHERE ebeln = im_ebeln.
IF sy-subrc = 0.

***the following code repeats for each line of the outbound delivery to
LOOP AT lt_ekpo ASSIGNING FIELD-SYMBOL(<lfs_ekpo>).
ls_goodsmvt_item-move_type  = '101'.                   "moveme
ls_goodsmvt_item-material   = <lfs_ekpo>-matnr.        "materi
ls_goodsmvt_item-plant      = <lfs_ekpo>-werks.        "receiv
ls_goodsmvt_item-stge_loc   = 'KS01'.                  "receiv
ls_goodsmvt_item-entry_qnt  = <lfs_ekpo>-menge.        "quanti
ls_goodsmvt_item-entry_uom  = <lfs_ekpo>-meins.        "unit O
ls_goodsmvt_item-po_number  = <lfs_ekpo>-ebeln.
ls_goodsmvt_item-po_item    = <lfs_ekpo>-ebelp.
ls_goodsmvt_item-batch      = '15000'.
*          ls_goodsmvt_item-no_more_gr = 'X'.                          "
ls_goodsmvt_item-mvt_ind    = 'B'.                     "(repre

APPEND ls_goodsmvt_item TO lt_goodsmvt_item.
CLEAR : ls_goodsmvt_item.
ENDLOOP.
ENDIF.
**********************************************************************
ENDIF.

*Simulate Goods Receipt for Outbound Delivery
CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
EXPORTING
goodsmvt_header = ls_goodsmvt_header
goodsmvt_code   = lv_goodsmvt_code
testrun         = 'X'
TABLES
goodsmvt_item   = lt_goodsmvt_item
return          = ex_return.
*Create Goods Receipt for Outbound Delivery
IF sy-subrc = 0 AND ex_return IS INITIAL.
CALL FUNCTION 'BAPI_GOODSMVT_CREATE'
EXPORTING
goodsmvt_header  = ls_goodsmvt_header
goodsmvt_code    = lv_goodsmvt_code
IMPORTING
materialdocument = lv_mat_doc
matdocumentyear  = lv_year
TABLES
goodsmvt_item    = lt_goodsmvt_item
return           = ex_return.

*Commit
IF sy-subrc = 0 AND lv_mat_doc IS NOT INITIAL AND lv_year IS NOT I
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait = abap_true.
ls_return-message_v1 = lv_mat_doc.
ls_return-message_v2 = lv_year.
ls_return-message    = 'The Goods Receipt Created'.
ls_return-type       = 'I'.
ls_return-number     = '001'.
APPEND ls_return TO ex_return.
ENDIF.
ENDIF.
ENDMETHOD.
CANCEL_GOODS_RECEIPT
item
METHOD cancel_goods_receipt.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Zareena Begum
* Created on  : 5th-April-2018
* Description : Cancel Goods Receipt
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*

*Types Declarations
TYPES : BEGIN OF lty_mkpf,
mblnr TYPE mkpf-mblnr,
mjahr TYPE mkpf-mjahr,
END OF lty_mkpf.

**Data Declarations
DATA : ls_goods_receipt       TYPE yss_s_range,
lt_mkpf                TYPE TABLE OF lty_mkpf,
lt_goodsmvt_matdocitem TYPE TABLE OF bapi2017_gm_item_04,
ls_goodsmvt_headert    TYPE bapi2017_gm_head_ret,
lt_return              TYPE bapiret2_t,
ls_return              TYPE bapiret2,
ls_mkpf                TYPE lty_mkpf.

*Material Document Header
SELECT mblnr
mjahr
FROM mkpf
INTO TABLE lt_mkpf
WHERE mblnr IN im_mblnr AND
vgart IN ('WE','WF').
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.
SORT lt_mkpf BY mblnr.

*Cancel Goods Receipt
LOOP AT lt_mkpf ASSIGNING FIELD-SYMBOL(<lfs_mkpf>).
CALL FUNCTION 'BAPI_GOODSMVT_CANCEL'
EXPORTING
materialdocument    = <lfs_mkpf>-mblnr
matdocumentyear     = <lfs_mkpf>-mjahr
*         GOODSMVT_PSTNG_DATE =
*         GOODSMVT_PR_UNAME   =
IMPORTING
goodsmvt_headret    = ls_goodsmvt_headert
TABLES
return              = lt_return
goodsmvt_matdocitem = lt_goodsmvt_matdocitem.

READ TABLE lt_return TRANSPORTING NO FIELDS WITH KEY type = 'E'.
IF sy-subrc NE 0.
CHECK ls_goodsmvt_headert-mat_doc IS NOT INITIAL.
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait = abap_true.

ls_return-type   = 'S'.
ls_return-number = '049'.
ls_return-id     = 'YSS'.
MESSAGE ID 'YSS' TYPE 'S' NUMBER '049' INTO ls_return-message.
APPEND ls_return TO ex_return.
ENDIF.
APPEND LINES OF lt_return TO ex_return.
IF ls_goodsmvt_headert-mat_doc IS NOT INITIAL.
APPEND ls_goodsmvt_headert TO ex_goodsmvt_headert.
ENDIF.
CLEAR: lt_return, ls_return, ls_goodsmvt_headert .
ENDLOOP.


ENDMETHOD.
FETCH_PENDING_PO_LIST
item
METHOD fetch_pending_po_list.
TYPES : BEGIN OF lty_lfa1,
lifnr TYPE lifnr,
name1 TYPE ad_name1,
name2 TYPE ad_name2,
END OF lty_lfa1,
BEGIN OF lty_t001w,
werks TYPE werks_d,
name1 TYPE ad_name1,
END OF lty_t001w,
BEGIN OF lty_ekpo,
ebeln	TYPE ebeln,
ebelp	TYPE ebelp,
effwr TYPE effwr,
END OF lty_ekpo.

DATA : lt_return    TYPE yss_tt_bapireturn,
lt_item_temp TYPE yss_tt_bapiekpo,
lt_item      TYPE yss_tt_bapiekpo,
lt_header    TYPE yss_tt_bapiekko,
lt_lfa1      TYPE TABLE OF lty_lfa1,
lt_t001w     TYPE TABLE OF lty_t001w,
lt_ekpo      TYPE TABLE OF lty_ekpo,
lv_effwr     TYPE effwr.

*  Get List of Purchase Orders
CALL FUNCTION 'BAPI_PO_GET_LIST'
EXPORTING
rel_group                  = yss_cl_type_pool=>yss_c_frggr   "Re
rel_code                   = yss_cl_type_pool=>yss_c_frgco   "Re
items_for_release          = abap_true
TABLES
po_headers                 = lt_header                       "He
po_items                   = lt_item                         "It
return                     = lt_return
EXCEPTIONS
rel_code_missing           = 1
rel_authority_check_failed = 2
OTHERS                     = 3.
SELECT lifnr name1 name2 FROM lfa1 INTO TABLE lt_lfa1 FOR ALL ENTRIE
IF sy-subrc EQ 0.
SORT lt_lfa1 BY lifnr.
ENDIF.
MOVE-CORRESPONDING lt_return TO ex_return.
IF lt_header IS INITIAL.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.

lt_item_temp = lt_item.
SORT lt_item_temp BY po_number.
DELETE ADJACENT DUPLICATES FROM lt_item_temp COMPARING po_number.
SORT lt_item_temp BY po_number.
DATA(lt_item_temp1) = lt_item_temp.
SORT lt_item_temp1 BY plant.
DELETE ADJACENT DUPLICATES FROM lt_item_temp1 COMPARING plant.
SELECT werks
name1
FROM t001w
INTO TABLE lt_t001w
FOR ALL ENTRIES IN lt_item_temp1
WHERE werks = lt_item_temp1-plant.
IF sy-subrc EQ 0.
SORT lt_t001w BY werks.
ENDIF.
IF lt_header IS NOT INITIAL.
SELECT ebeln
ebelp
effwr
FROM ekpo
INTO TABLE lt_ekpo
FOR ALL ENTRIES IN lt_header
WHERE ebeln = lt_header-po_number
AND   loekz NE abap_true.
IF sy-subrc EQ 0.
SORT lt_ekpo BY ebeln.
ENDIF.
ENDIF.
LOOP AT lt_header ASSIGNING FIELD-SYMBOL(<lfs_header>).
APPEND INITIAL LINE TO ex_pending_po_list ASSIGNING FIELD-SYMBOL(<
<lfs_po_list>-po_number   = <lfs_header>-po_number.
<lfs_po_list>-po_date     = <lfs_header>-doc_date.

LOOP AT lt_ekpo ASSIGNING FIELD-SYMBOL(<lfs_ekpo>) WHERE ebeln = <
lv_effwr = lv_effwr + <lfs_ekpo>-effwr.
ENDLOOP.
<lfs_po_list>-po_amount   = lv_effwr.
CLEAR lv_effwr.
*      <lfs_po_list>-po_amount   = <lfs_header>-target_val.
<lfs_po_list>-status      = yss_cl_type_pool=>yss_c_pending.
<lfs_po_list>-status_id   = <lfs_header>-rel_ind.
*Vendor name
READ TABLE lt_lfa1 ASSIGNING FIELD-SYMBOL(<lfs_lfa1>) WITH KEY lif
IF sy-subrc EQ 0.
IF <lfs_lfa1>-name2 IS INITIAL.
<lfs_po_list>-vendor_name = <lfs_lfa1>-name1.
ELSE.
CONCATENATE <lfs_lfa1>-name1 <lfs_lfa1>-name2 INTO <lfs_po_lis
ENDIF.
ENDIF.
*receiving plant
READ TABLE lt_item_temp ASSIGNING FIELD-SYMBOL(<lfs_item_temp>)
WITH KEY po_number = <lfs_header>-po_number BINARY SEARCH.
IF sy-subrc EQ 0.
<lfs_po_list>-plant = <lfs_item_temp>-plant.
ENDIF.
*plant name
READ TABLE lt_t001w ASSIGNING FIELD-SYMBOL(<lfs_t001w>) WITH KEY w
IF sy-subrc EQ 0.
<lfs_po_list>-plant_name = <lfs_t001w>-name1.
ENDIF.
ENDLOOP.


IF <lfs_header> IS ASSIGNED.
UNASSIGN <lfs_header>.
ENDIF.
IF <lfs_item_temp> IS ASSIGNED.
UNASSIGN <lfs_item_temp>.
ENDIF.


ENDMETHOD.
RELEASE_PURCHASE_ORDER
item
METHOD release_purchase_order.
DATA :
lv_frgco    TYPE frgco VALUE yss_cl_type_pool=>yss_c_frgco,
i_no_commit TYPE ekpo-statu VALUE abap_true,
lv_status   TYPE char1 VALUE abap_true,
lt_return   TYPE TABLE OF bapireturn.
*Release of an purchase order
CALL FUNCTION 'WOD1_RELEASE_PURCHASE_ORDER'
EXPORTING
i_ebeln     = purchaseorder
i_frgco     = lv_frgco
i_no_commit = i_no_commit
CHANGING
ch_status   = lv_status.

CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait = abap_true.

*Display Detailed Release (Approval) Information on Purchase Order
CALL FUNCTION 'BAPI_PO_GETRELINFO'
EXPORTING
purchaseorder        = purchaseorder
po_rel_code          = lv_frgco
IMPORTING
general_release_info = ex_release_info
*       release_prerequisites  = ex_release_prerequisites
*       release_already_posted = ex_release_already_posted
TABLES
*       release_final        = ex_release_final
return               = lt_return.



MOVE-CORRESPONDING lt_return TO ex_return.

ENDMETHOD.
SIMULATE_CREATE_PO
item
METHOD simulate_create_po.
TYPES : BEGIN OF lty_mat_prc,
matnr TYPE matnr,
price TYPE kbetr,
END OF lty_mat_prc.
DATA : ls_poheader_1        TYPE bapimepoheader,
ls_poheaderx_1       TYPE bapimepoheaderx,
lt_ret1              TYPE TABLE OF bapiret2,
lt_poitem1           TYPE TABLE OF bapimepoitem,
lt_poitemx1          TYPE TABLE OF bapimepoitemx,
lt_poschedule1       TYPE TABLE OF bapimeposchedule,
lt_poschedulex1      TYPE TABLE OF bapimeposchedulx,
lt_pocond1           TYPE TABLE OF bapimepocond,
lt_mbew              TYPE TABLE OF mbew,
lt_a701              TYPE TABLE OF a701,
lt_konp              TYPE TABLE OF konp,
lt_mat_prc           TYPE TABLE OF lty_mat_prc,
lt_mat_prc_2         TYPE TABLE OF lty_mat_prc,
lt_poshippingexp1    TYPE TABLE OF bapimeposhippexp,
lt_mat_price_po      TYPE yss_tt_mat_price_po,
ls_t001w             TYPE t001w,
lv_pltyp             TYPE pltyp,
lv_werks             TYPE werks_ext,
lv_werks_check       TYPE werks_ext,
lv_kunnr             TYPE kunnr,
lv_net_price         TYPE bprei,
lt_matnr             TYPE matnr_tty,
lt_817               TYPE TABLE OF a817,
*--------------------------------------------------------------------*
lt_poaccount1        TYPE TABLE OF bapimepoaccount,
lt_bapimeposhippexp1 TYPE TABLE OF bapimeposhippexp,
lv_sim_flag          TYPE char1,
lt_mat               TYPE yss_tt_mat,
*--------------------------------------------------------------------*
lv_kunwe             TYPE kunwe,
lt_poshipping        TYPE TABLE OF bapiitemship, "Added on 28
lt_poshippingx	      TYPE TABLE OF bapiitemshipx,
** SOC Purna  SNDK902572
lv_werks_shp         TYPE rvari_val_255,
lv_plant             TYPE werks_ext.
** EOC Purna SNDK902572

SELECT SINGLE werks
FROM lfa1
INTO lv_werks_check
WHERE lifnr = im_po_header-vendor.
IF sy-subrc EQ 0.

ENDIF.
*pass header data to bapi structure
ls_poheader_1-comp_code = yss_cl_type_pool=>yss_c_rmss.
ls_poheader_1-purch_org = yss_cl_type_pool=>yss_c_rmss.
ls_poheader_1-doc_type  = im_po_header-doc_type.
ls_poheader_1-vendor    = im_po_header-vendor.
ls_poheader_1-our_ref   = im_po_header-agreement.
ls_poheader_1-langu     = yss_cl_type_pool=>yss_c_e.
ls_poheader_1-pur_group = yss_cl_type_pool=>yss_c_pur_grp.     "KSP
*For KAD hospital users
IF im_req_params-werks+0(1) EQ yss_cl_type_pool=>yss_c_k.
ls_poheader_1-ref_1       = im_po_ref_doc.
ls_poheader_1-collect_no  = im_po_ref_doc.
ls_poheaderx_1-ref_1      = abap_true.
ls_poheaderx_1-collect_no = abap_true.
ENDIF.
*populate HEADERX structure
ls_poheaderx_1-comp_code = abap_true.
ls_poheaderx_1-doc_type  = abap_true.
ls_poheaderx_1-vendor    = abap_true.
ls_poheaderx_1-langu     = abap_true.
ls_poheaderx_1-purch_org = abap_true.
ls_poheaderx_1-pur_group = abap_true.
ls_poheaderx_1-our_ref   = abap_true.


*preparing line item table for BAPI
LOOP AT im_po_items ASSIGNING FIELD-SYMBOL(<lfs_item>).
*poitem populate
APPEND INITIAL LINE TO lt_poitem1 ASSIGNING FIELD-SYMBOL(<lfs_poit
IF sy-subrc EQ 0.
MOVE-CORRESPONDING <lfs_item> TO <lfs_poitem1>.
<lfs_poitem1>-plant = im_req_params-werks.
READ TABLE im_po_item_schedules ASSIGNING FIELD-SYMBOL(<lfs_item
WITH KEY po_item = <lfs_item>-po_item BINARY SEARCH.
IF sy-subrc EQ 0.
<lfs_poitem1>-quantity = <lfs_item_schedules>-quantity.
ENDIF.
<lfs_poitem1>-gr_basediv = abap_true.
<lfs_poitem1>-gr_ind     = abap_true.
<lfs_poitem1>-ir_ind     = abap_true.
IF ls_poheader_1-doc_type EQ yss_cl_type_pool=>yss_c_doc_ty_zrn.
<lfs_poitem1>-ret_item   = abap_true.
<lfs_poitem1>-po_price = '1'.
ENDIF.
<lfs_poitem1>-stge_loc   = 'KS01'.
ENDIF.
*poitemx populate
APPEND INITIAL LINE TO lt_poitemx1 ASSIGNING FIELD-SYMBOL(<lfs_poi
IF sy-subrc EQ 0.
<lfs_poitemx1>-po_item      = <lfs_item>-po_item.
<lfs_poitemx1>-po_itemx     = abap_true.
<lfs_poitemx1>-material     = abap_true.
<lfs_poitemx1>-plant        = abap_true.
<lfs_poitemx1>-stge_loc     = abap_true.
<lfs_poitemx1>-quantity     = abap_true.
<lfs_poitemx1>-net_price    = abap_true.
<lfs_poitemx1>-gr_basediv   = abap_true.
<lfs_poitemx1>-gr_ind       = abap_true.
<lfs_poitemx1>-ir_ind       = abap_true.
IF ls_poheader_1-doc_type EQ yss_cl_type_pool=>yss_c_doc_ty_zrn.
<lfs_poitemx1>-ret_item = abap_true.
<lfs_poitemx1>-po_price = abap_true.
ENDIF.
ENDIF.
*Schedule
APPEND INITIAL LINE TO lt_poschedule1 ASSIGNING FIELD-SYMBOL(<lfs_
IF sy-subrc EQ 0.
<lfs_poschedule1>-po_item = <lfs_item>-po_item.
READ TABLE im_po_item_schedules ASSIGNING <lfs_item_schedules>
WITH KEY po_item = <lfs_item>-po_item BINARY SEARCH.
IF sy-subrc EQ 0.
<lfs_poschedule1>-quantity      = <lfs_item_schedules>-quantit
<lfs_poschedule1>-delivery_date = <lfs_item_schedules>-deliv_d
ENDIF.
ENDIF.
*Scedulex
APPEND INITIAL LINE TO lt_poschedulex1 ASSIGNING FIELD-SYMBOL(<lfs
IF sy-subrc EQ 0.
<lfs_poschedulex1>-po_item       = <lfs_item>-po_item.
<lfs_poschedulex1>-quantity      = abap_true.
<lfs_poschedulex1>-delivery_date = abap_true.
ENDIF.
***Add shipping point
** SOC Purna SNDK902572
*      IF im_req_params-werks+0(1) EQ yss_cl_type_pool=>yss_c_k AND
*         lv_werks_check = '6352'.
IF im_req_params-werks+0(1) EQ yss_cl_type_pool=>yss_c_k.
** Select the value from table TVARVC for shipping point
CLEAR: lv_plant,
lv_werks_shp.
CONCATENATE 'YSS_PO_' lv_werks_check
INTO lv_werks_shp.
SELECT low UP TO 1 ROWS
INTO lv_plant
FROM tvarvc
WHERE name EQ lv_werks_shp
AND  type EQ 'P'.
ENDSELECT.
IF sy-subrc NE 0.
** Do nothing
ENDIF.
** EOC Purna SNDK902572

APPEND INITIAL LINE TO lt_poshipping
ASSIGNING FIELD-SYMBOL(<lfs_poshipping>).
*        IF sy-subrc EQ 0.
<lfs_poshipping>-po_item = <lfs_item>-po_item.
*        <lfs_poshipping>-ship_point = 'K352'.  " Purna SNDK902572
<lfs_poshipping>-ship_point = lv_plant. " Purna SNDK902572
*        ENDIF.
APPEND INITIAL LINE TO lt_poshippingx
ASSIGNING FIELD-SYMBOL(<lfs_poshippingx>).
*        IF sy-subrc EQ 0.
<lfs_poshippingx>-po_item = <lfs_item>-po_item.
<lfs_poshippingx>-ship_point = abap_true.
*        ENDIF.
ENDIF.
ENDLOOP.
*    BREAK-POINT.
*Create Purchase Order
CALL FUNCTION 'BAPI_PO_CREATE1'
EXPORTING
poheader    = ls_poheader_1
poheaderx   = ls_poheaderx_1
testrun     = im_simulate
TABLES
return      = lt_ret1
poitem      = lt_poitem1
poitemx     = lt_poitemx1
poschedule  = lt_poschedule1
poschedulex = lt_poschedulex1
pocond      = lt_pocond1
poshipping  = lt_poshipping
poshippingx = lt_poshippingx.

ex_return = lt_ret1.

IF im_simulate IS INITIAL.
READ TABLE lt_ret1 ASSIGNING FIELD-SYMBOL(<lfs_ret1>) INDEX 1.
IF sy-subrc EQ 0.
ex_po_number = <lfs_ret1>-message_v2.
ENDIF.
ENDIF.

LOOP AT lt_pocond1 ASSIGNING FIELD-SYMBOL(<lfs_cond1>) .
IF <lfs_cond1>-cond_type NE 'JICG' AND
<lfs_cond1>-cond_type NE 'JISG' AND
<lfs_cond1>-cond_type NE 'JIIG'.
DELETE lt_pocond1.
ENDIF.
ENDLOOP.

*get material description
SELECT   matnr
maktx
FROM makt
INTO TABLE lt_mat
FOR ALL ENTRIES IN lt_poitem1
WHERE matnr = lt_poitem1-material.
IF sy-subrc EQ 0.
SORT lt_mat BY mat_num.
ENDIF.

LOOP AT im_po_items ASSIGNING <lfs_item>.
APPEND INITIAL LINE TO lt_mat_price_po ASSIGNING FIELD-SYMBOL(<lfs
<lfs_price_po>-item_no = <lfs_item>-po_item.
<lfs_price_po>-mat_id  = <lfs_item>-material.
READ TABLE lt_poitem1 ASSIGNING FIELD-SYMBOL(<lfs_item1>)
WITH KEY po_item = <lfs_item>-po_item BINARY SEARCH.
IF sy-subrc EQ 0.
<lfs_price_po>-uom     = <lfs_item1>-po_unit.
ENDIF.
READ TABLE lt_mat ASSIGNING FIELD-SYMBOL(<lfs_mat>) WITH KEY mat_n
IF sy-subrc EQ 0.
<lfs_price_po>-mat_desc = <lfs_mat>-mat_name.
ENDIF.

READ TABLE im_po_item_schedules ASSIGNING FIELD-SYMBOL(<lfs_sched>
WITH KEY po_item = <lfs_item>-po_item BINARY SEARCH.
IF sy-subrc EQ 0.
<lfs_price_po>-mat_quan = <lfs_sched>-quantity.
ENDIF.
IF ls_poheader_1-suppl_plnt IS INITIAL.
LOOP AT lt_pocond1 ASSIGNING <lfs_cond1> WHERE itm_number = <lfs
IF <lfs_cond1>-cond_type = 'JICG'.
<lfs_price_po>-cgst_rate = <lfs_cond1>-cond_value.
ENDIF.
IF <lfs_cond1>-cond_type = 'JIIG'.
<lfs_price_po>-igst_rate = <lfs_cond1>-cond_value.
ENDIF.
IF <lfs_cond1>-cond_type = 'JISG'.
<lfs_price_po>-sgst_rate = <lfs_cond1>-cond_value.
ENDIF.
ENDLOOP.
ENDIF.
APPEND INITIAL LINE TO lt_matnr ASSIGNING FIELD-SYMBOL(<lfs_matnr>
<lfs_matnr> = <lfs_item>-material.
ENDLOOP.

IF im_req_params+0(1) EQ yss_cl_type_pool=>yss_c_s.
*----------------------For S* user--------------------------*
CASE im_po_header-doc_type.

WHEN 'YNB'.
********************************************************************** A
DATA : lt_017 TYPE TABLE OF a017.
SELECT *
FROM a017
INTO TABLE lt_017
FOR ALL ENTRIES IN im_po_items
WHERE werks = im_req_params-werks
AND lifnr = im_po_header-vendor    "Vendor code
AND matnr = im_po_items-material   "Material number
AND ekorg = yss_cl_type_pool=>yss_c_rmss."purchasing org.

LOOP AT lt_017 ASSIGNING FIELD-SYMBOL(<lfs_017>).
IF sy-datum NOT BETWEEN <lfs_017>-datab AND <lfs_017>-datbi.
CLEAR <lfs_017>.
ENDIF.
ENDLOOP.
DELETE lt_017 WHERE kappl IS INITIAL AND kschl IS INITIAL.

CHECK lt_017 IS NOT INITIAL.

*get conditions from KONP
SELECT * FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_017
WHERE knumh = lt_017-knumh.
IF sy-subrc EQ 0.
SORT : lt_017 BY matnr,
lt_mat_price_po BY mat_id,
lt_konp BY knumh.
ENDIF.

LOOP AT lt_mat_price_po ASSIGNING FIELD-SYMBOL(<lfs_pr_po>).
READ TABLE lt_017 ASSIGNING <lfs_017> WITH KEY matnr = <lfs_
IF sy-subrc EQ 0.
READ TABLE lt_konp ASSIGNING FIELD-SYMBOL(<lfs_konp>) WITH
IF <lfs_konp>-loevm_ko EQ abap_false.
<lfs_pr_po>-mat_price = <lfs_konp>-kbetr.
ELSE.
CONTINUE.
ENDIF.
ELSE.
APPEND INITIAL LINE TO lt_mat_prc ASSIGNING FIELD-SYMBOL(<
<lfs_mat_prc>-matnr =  <lfs_pr_po>-mat_id.
ENDIF.
ENDLOOP.

IF lt_mat_prc IS NOT INITIAL.
SELECT * FROM mbew INTO TABLE lt_mbew
FOR ALL ENTRIES IN lt_mat_prc
WHERE matnr = lt_mat_prc-matnr AND
bwkey = lv_werks.
IF sy-subrc EQ 0.
SORT lt_mbew BY matnr.
LOOP AT lt_mat_price_po ASSIGNING <lfs_price_po>.
READ TABLE lt_mbew ASSIGNING FIELD-SYMBOL(<lfs_mbew>)
WITH KEY matnr = <lfs_price_po>-mat_id BINARY SEARCH.
IF sy-subrc EQ 0.
IF <lfs_mbew>-vprsv EQ 'S'.
<lfs_price_po>-mat_price = <lfs_mbew>-stprs.
ENDIF.
IF <lfs_mbew>-vprsv EQ 'V'.
<lfs_price_po>-mat_price = <lfs_mbew>-verpr.
ENDIF.
ENDIF.
ENDLOOP.
ENDIF.
ENDIF.
********************************************************************** A

WHEN OTHERS.
*get vendor plant
SELECT SINGLE werks
FROM lfa1
INTO lv_werks
WHERE lifnr = im_po_header-vendor.
IF sy-subrc EQ 0.
"Do nothing
ENDIF.

SELECT SINGLE *
FROM t001w
INTO ls_t001w
WHERE werks = lv_werks.
IF sy-subrc EQ 0.
"Do nothing
ENDIF.

*Get Customer number of vendor plant
SELECT SINGLE kunnr
FROM t001w
INTO lv_kunnr
WHERE werks = im_req_params-werks.
IF sy-subrc EQ 0.
"Do nothing
ENDIF.
*Get price list
SELECT SINGLE pltyp
FROM knvv
INTO lv_pltyp
WHERE vkorg = ls_t001w-vkorg AND
vtweg = ls_t001w-vtweg AND
spart = ls_t001w-spart AND
kunnr = lv_kunnr       AND
loevm = abap_false.
*get material price
SELECT * FROM a701
INTO TABLE lt_a701
FOR ALL ENTRIES IN im_po_items
WHERE matnr = im_po_items-material AND
pltyp = lv_pltyp.
*delete records where current date does not lie between date range DATAB
LOOP AT lt_a701 ASSIGNING FIELD-SYMBOL(<lfs_a701>).
IF sy-datum NOT BETWEEN <lfs_a701>-datab AND <lfs_a701>-datb
CLEAR <lfs_a701>.
ENDIF.
ENDLOOP.
DELETE lt_a701 WHERE kappl IS INITIAL AND kschl IS INITIAL.

CHECK lt_a701 IS NOT INITIAL.

*get conditions from KONP
SELECT * FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_a701
WHERE knumh = lt_a701-knumh.
IF sy-subrc EQ 0.
SORT : lt_a701 BY matnr,
lt_mat_price_po BY mat_id,
lt_konp BY knumh.
ENDIF.

LOOP AT lt_mat_price_po ASSIGNING <lfs_pr_po>.
READ TABLE lt_a701 ASSIGNING <lfs_a701> WITH KEY matnr = <lf
IF sy-subrc EQ 0.
READ TABLE lt_konp ASSIGNING <lfs_konp> WITH KEY knumh = <
IF <lfs_konp>-loevm_ko EQ abap_false.
<lfs_pr_po>-mat_price = <lfs_konp>-kbetr.
ELSE.
CONTINUE.
ENDIF.
ELSE.
APPEND INITIAL LINE TO lt_mat_prc ASSIGNING <lfs_mat_prc>.
<lfs_mat_prc>-matnr =  <lfs_pr_po>-mat_id.
ENDIF.
ENDLOOP.

IF lt_mat_prc IS NOT INITIAL.
SELECT * FROM mbew INTO TABLE lt_mbew
FOR ALL ENTRIES IN lt_mat_prc
WHERE matnr = lt_mat_prc-matnr AND
bwkey = lv_werks.
IF sy-subrc EQ 0.
SORT lt_mbew BY matnr.
LOOP AT lt_mat_price_po ASSIGNING <lfs_price_po>.
READ TABLE lt_mbew ASSIGNING <lfs_mbew>
WITH KEY matnr = <lfs_price_po>-mat_id BINARY SEARCH.
IF sy-subrc EQ 0.
IF <lfs_mbew>-vprsv EQ 'S'.
<lfs_price_po>-mat_price = <lfs_mbew>-stprs.
ENDIF.
IF <lfs_mbew>-vprsv EQ 'V'.
<lfs_price_po>-mat_price = <lfs_mbew>-verpr.
ENDIF.
ENDIF.
ENDLOOP.
ENDIF.
ENDIF.
ENDCASE.
ELSE.
*----------------------For K* user-----------------------------*

CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = im_po_ref_doc
IMPORTING
output = lv_kunwe.

SELECT * FROM a817
INTO TABLE lt_817
FOR ALL ENTRIES IN im_po_items
WHERE matnr = im_po_items-material AND
kunwe = lv_kunwe AND
vtweg = yss_cl_type_pool=>yss_c_st AND
kschl = yss_cl_type_pool=>yss_c_zpro.
IF sy-subrc EQ 0.
*get conditions from konp
SELECT * FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_817
WHERE knumh = lt_817-knumh.
IF sy-subrc EQ 0.
SORT : lt_817 BY matnr,
lt_mat_price_po BY mat_id,
lt_konp BY knumh.
ENDIF.
*delete records where current date does not lie between date range DATAB
LOOP AT lt_817 ASSIGNING FIELD-SYMBOL(<lfs_a817>).
IF sy-datum NOT BETWEEN <lfs_a817>-datab AND <lfs_a817>-datbi.
CLEAR <lfs_a817>.
ENDIF.
ENDLOOP.
DELETE lt_817 WHERE kappl IS INITIAL AND kschl IS INITIAL.

LOOP AT lt_mat_price_po ASSIGNING <lfs_pr_po>.
READ TABLE lt_817 ASSIGNING <lfs_a817> WITH KEY matnr = <lfs_p
IF sy-subrc EQ 0.
READ TABLE lt_konp ASSIGNING <lfs_konp> WITH KEY knumh = <lf
IF <lfs_konp>-loevm_ko EQ abap_false.
<lfs_pr_po>-mat_price = <lfs_konp>-kbetr.
ELSE.
CONTINUE.
ENDIF.
ELSE.
APPEND INITIAL LINE TO lt_mat_prc_2 ASSIGNING <lfs_mat_prc>.
<lfs_mat_prc>-matnr =  <lfs_pr_po>-mat_id.
ENDIF.
ENDLOOP.

IF lt_mat_prc IS NOT INITIAL.
SELECT * FROM mbew INTO TABLE lt_mbew
FOR ALL ENTRIES IN lt_mat_prc_2
WHERE matnr = lt_mat_prc_2-matnr AND
bwkey = lv_werks.
IF sy-subrc EQ 0.
SORT lt_mbew BY matnr.
LOOP AT lt_mat_price_po ASSIGNING <lfs_price_po>.
READ TABLE lt_mbew ASSIGNING <lfs_mbew>
WITH KEY matnr = <lfs_price_po>-mat_id BINARY SEARCH.
IF sy-subrc EQ 0.
IF <lfs_mbew>-vprsv EQ 'S'.
<lfs_price_po>-mat_price = <lfs_mbew>-stprs.
ENDIF.
IF <lfs_mbew>-vprsv EQ 'V'.
<lfs_price_po>-mat_price = <lfs_mbew>-verpr.
ENDIF.
ENDIF.
ENDLOOP.
ENDIF.
ENDIF.
ENDIF.
ENDIF.
LOOP AT lt_mat_price_po ASSIGNING <lfs_price_po>.
lv_net_price = <lfs_price_po>-mat_quan * <lfs_price_po>-mat_price.
<lfs_price_po>-cgst_value = lv_net_price * ( <lfs_price_po>-cgst_r
<lfs_price_po>-igst_value = lv_net_price * ( <lfs_price_po>-igst_r
<lfs_price_po>-sgst_value = lv_net_price * ( <lfs_price_po>-sgst_r
<lfs_price_po>-net_price =  lv_net_price + <lfs_price_po>-cgst_val
ENDLOOP.
ex_po_price_list = lt_mat_price_po.
ENDMETHOD.
FETCH_PURCHASE_SCHEMES
item
METHOD fetch_purchase_schemes.
*---------------------------------------------------------------------*
*                    A D M I N I S T R A T I O N
*---------------------------------------------------------------------*
* Organization: Incresol Software Services Private Limited            *
* Created by  : Abhishek T                                            *
* Created on  : 19-Feb-2018                                           *
* Description : Method to get scheme details for particular customer
*---------------------------------------------------------------------*
*                       C H A N G E    L O G
*---------------------------------------------------------------------*
* <Changed by> | <Changed on> | <Change ID> like USERNAME.DDMMYY
* <Description of change>
*---------------------------------------------------------------------*
TYPES : lty_r_matnr TYPE RANGE OF matnr,
BEGIN OF lty_knumh,
knumh TYPE knumh,
konwa TYPE konwa,
END OF lty_knumh,
BEGIN OF lty_a305,
matnr TYPE matnr,
knumh TYPE knumh,
END OF lty_a305,
BEGIN OF lty_makt,
matnr TYPE matnr,
maktx TYPE maktx,
END OF lty_makt,
BEGIN OF lty_konp,
knumh	   TYPE knumh,
kopos    TYPE kopos,
kzbzg    TYPE kzbzg,
kstbm	   TYPE kstbm,
konms    TYPE konms,
kbetr	   TYPE kbetr_kond,
konwa    TYPE konwa,
loevm_ko TYPE loevm_ko,
END OF lty_konp,
BEGIN OF lty_konm,
knumh	TYPE knumh,
kstbm	TYPE kstbm,
kbetr	TYPE kbetr_kond,
konwa TYPE konwa,
END OF lty_konm.

DATA :
*Internal table
lt_a305         TYPE TABLE OF lty_a305,
lt_knumh        TYPE TABLE OF lty_knumh,
lt_konm         TYPE TABLE OF lty_konm,
lt_konm_temp    TYPE TABLE OF lty_konm,
lt_konp         TYPE TABLE OF lty_konp,
lt_makt         TYPE TABLE OF lty_makt,
lt_schemes1     TYPE yss_tt_pro,
*Ranges
lr_matnr        TYPE lty_r_matnr,
lr_kappl        TYPE rsdsselopt_t,
lr_kschl        TYPE rsdsselopt_t,
*Work areas
ls_matnr        TYPE LINE OF lty_r_matnr,
ls_sales_area   TYPE yss_s_sales_area,
ls_schemes      TYPE yss_s_schemes,
ls_konm         TYPE lty_konm,
ls_konp         TYPE lty_konp,
ls_knumh        TYPE lty_knumh,
ls_schemes_temp TYPE yss_s_pro,
*class object
lo_exception    TYPE REF TO ycx_ss_exception.

FIELD-SYMBOLS : <lfs_matnr> TYPE matnr,
<lfs_makt>  TYPE lty_makt,
<lfs_konp>  TYPE lty_konp,
<lfs_a305>  TYPE lty_a305,
<lfs_knumh> TYPE lty_knumh.

* To check customer validation
TRY .
CALL METHOD yss_cl_sd_process=>validate_customer
EXPORTING
im_customer = im_kunnr
im_werks    = im_req_params-werks.
CATCH ycx_ss_exception INTO lo_exception.
lo_exception->log_exception( ).
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>invalid_customer
msgv1  = ycx_ss_exception=>format( im_kunnr ).
RETURN.
ENDTRY.

IF im_matnr_tt IS NOT INITIAL.
LOOP AT im_matnr_tt ASSIGNING <lfs_matnr>.
ls_matnr-low = <lfs_matnr>.
ls_matnr-sign = yss_cl_type_pool=>yss_c_sign_i.
ls_matnr-option = yss_cl_type_pool=>yss_c_opt_eq.
APPEND ls_matnr TO lr_matnr.
ENDLOOP.
ENDIF.


*decide sales area ( RMSD,ST)
ls_sales_area-vkorg = yss_cl_type_pool=>yss_c_rmsd.
ls_sales_area-vtweg = yss_cl_type_pool=>yss_c_st.

*Fetch record from A305
SELECT matnr
knumh
FROM a305
INTO TABLE lt_a305
WHERE vkorg = ls_sales_area-vkorg AND
vtweg = ls_sales_area-vtweg AND
kunnr = im_kunnr            AND
matnr IN lr_matnr.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>schemes_not_found
msgv1  = ycx_ss_exception=>format( im_kunnr ).
ENDIF.
*fetch material text
SELECT  matnr  maktx
FROM makt INTO TABLE lt_makt
FOR ALL ENTRIES IN lt_a305
WHERE matnr = lt_a305-matnr AND
spras EQ yss_cl_type_pool=>yss_c_e.
IF sy-subrc EQ 0.
SORT lt_makt BY matnr.
ENDIF.

*Pass KNUMH to KONP.
SELECT knumh
kopos
kzbzg
kstbm
konms
kbetr
konwa
loevm_ko
FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_a305
WHERE knumh = lt_a305-knumh.
IF sy-subrc EQ 0.
SORT lt_a305 BY knumh.
SORT lt_konp BY knumh.

LOOP AT lt_konp INTO ls_konp.
DATA(lv_tabix) = sy-tabix + 1.
*1st condition check - Ignore the records KONP-LOEVM_KO = 'X'
IF  ls_konp-loevm_ko EQ abap_true.
CONTINUE.
ENDIF.
*2nd condition check - [ If the  KONP-KZBZG is blank, fetch KONP-KSTBM(q

IF ls_konp-kzbzg IS INITIAL.
READ TABLE lt_a305 ASSIGNING <lfs_a305> WITH KEY knumh = ls_ko
IF sy-subrc EQ 0.
ls_schemes-mat_id = <lfs_a305>-matnr.         "field 1 - mat
READ TABLE lt_makt ASSIGNING <lfs_makt> WITH KEY matnr = <lf
IF sy-subrc EQ 0.
ls_schemes-mat_desc = <lfs_makt>-maktx.     "field 2 - mat
ENDIF.
ENDIF.
*          ls_schemes_temp-qty = ls_konp-kstbm.
IF ls_konp-konwa EQ '%'.
ls_schemes_temp-rate = ls_konp-kbetr / 10.
ELSEIF ls_konp-konwa EQ yss_cl_type_pool=>yss_c_inr.
ls_schemes_temp-rate_value = ls_konp-kbetr.
ENDIF.
ls_schemes_temp-uom = ls_konp-konms.
ls_schemes_temp-min_quan = ls_konp-kstbm.
READ TABLE lt_konp INTO DATA(ls_konp_temp) INDEX lv_tabix.
IF sy-subrc EQ 0.
ls_schemes_temp-max_quan = ls_konp_temp-kstbm - 1.
ENDIF.
APPEND ls_schemes_temp TO lt_schemes1.
ls_schemes-schemes = lt_schemes1.          "field 3 - Schemes
APPEND ls_schemes TO ex_schemes.
REFRESH lt_schemes1.
*Go to KONM fetch data
ELSE.
ls_knumh-knumh = ls_konp-knumh.
ls_knumh-konwa = ls_konp-konwa.
APPEND ls_knumh TO lt_knumh.
ENDIF.
CLEAR : ls_schemes,ls_knumh,ls_schemes_temp,ls_konp_temp.
ENDLOOP.
ENDIF.

CLEAR lv_tabix.
*If KONP-KZBZG is not initial KONM fetch data
IF lt_knumh IS NOT INITIAL.
SORT lt_knumh BY knumh.
SELECT knumh
kstbm
kbetr
FROM konm
INTO TABLE lt_konm
FOR ALL ENTRIES IN  lt_knumh
WHERE knumh = lt_knumh-knumh.

LOOP AT lt_konm ASSIGNING FIELD-SYMBOL(<lfs_konm>).
READ TABLE lt_knumh ASSIGNING FIELD-SYMBOL(<lfs_knumh1>) WITH KE
IF sy-subrc EQ 0.
<lfs_konm>-konwa = <lfs_knumh1>-konwa.
ENDIF.
ENDLOOP.

LOOP AT lt_a305 ASSIGNING <lfs_a305>.
READ TABLE lt_knumh  TRANSPORTING NO FIELDS WITH KEY knumh = <lf
IF sy-subrc NE 0.
CLEAR <lfs_a305>.
CONTINUE.
ENDIF.

ls_schemes-mat_id = <lfs_a305>-matnr.
READ TABLE lt_makt ASSIGNING <lfs_makt> WITH KEY matnr = <lfs_a3
IF sy-subrc EQ 0.
ls_schemes-mat_desc = <lfs_makt>-maktx.
ENDIF.
lt_konm_temp = lt_konm.
DELETE lt_konm_temp WHERE knumh <> <lfs_a305>-knumh.
LOOP AT lt_konm_temp INTO ls_konm  WHERE knumh = <lfs_a305>-knum
lv_tabix = sy-tabix + 1.

*          ls_schemes_temp-qty = ls_konm-kstbm .
IF ls_konm-konwa EQ '%'.
ls_schemes_temp-rate = ls_konm-kbetr / 10.
ELSE.
ls_schemes_temp-rate_value =  ls_konm-kbetr.
ENDIF.

READ TABLE lt_konp ASSIGNING <lfs_konp> WITH KEY knumh = <lfs_
IF sy-subrc EQ 0.
ls_schemes_temp-uom = <lfs_konp>-konms.
ENDIF.

ls_schemes_temp-min_quan = ls_konm-kstbm.
CONDENSE ls_schemes_temp-min_quan NO-GAPS.
READ TABLE lt_konm_temp INTO DATA(ls_konm_temp) INDEX lv_tabix
IF sy-subrc EQ 0.
ls_schemes_temp-max_quan = ls_konm_temp-kstbm - 1.
ENDIF.
AT LAST.
ls_schemes_temp-max_quan = '&quan& +'.
REPLACE '&quan&' IN ls_schemes_temp-max_quan WITH ls_schemes
ENDAT.
CONDENSE ls_schemes_temp-max_quan NO-GAPS.
APPEND ls_schemes_temp TO ls_schemes-schemes.
CLEAR : ls_konm,ls_schemes_temp,ls_konm_temp,lv_tabix.
ENDLOOP.

APPEND ls_schemes TO ex_schemes.
CLEAR ls_schemes.
ENDLOOP.
DELETE lt_a305 WHERE matnr EQ space AND
knumh EQ space.
ENDIF.

IF <lfs_konp> IS ASSIGNED.
UNASSIGN <lfs_konp>.
ENDIF.
IF <lfs_makt> IS ASSIGNED.
UNASSIGN <lfs_makt>.
ENDIF.
IF <lfs_a305> IS ASSIGNED.
UNASSIGN <lfs_a305>.
ENDIF.
ENDMETHOD.
FETCH_GOODS_RECEIPT_DETAILS
item
METHOD fetch_goods_receipt_details.
*----------------------------------------------------------------------*
*                    A D M I N I S T R A T I O N
*----------------------------------------------------------------------*
* Organization: Incresol Software Services Private Limited             *
* Created by  : Abhishek T                                             *
* Created on  : 10.04.2018                                             *
* Description : To Fetch Goods Receipt Details                         *
*----------------------------------------------------------------------*
*                       C H A N G E    L O G
*----------------------------------------------------------------------*
* <Changed by> | <Changed on> | <Change ID> like USERNAME.DDMMYY
* <Description of change>
*----------------------------------------------------------------------*
TYPES : BEGIN OF lty_mkpf,
mblnr TYPE mblnr,
mjahr TYPE mjahr,
xblnr TYPE xblnr,
bktxt TYPE bktxt,
END OF lty_mkpf,
BEGIN OF lty_t001l,
werks TYPE werks_d,
lgort TYPE lgort_d,
lgobe TYPE lgobe,
END OF lty_t001l,
BEGIN OF lty_ekbe,
ebeln TYPE ebeln,
ebelp TYPE ebelp,
zekkn TYPE dzekkn,
vgabe TYPE vgabe,
gjahr TYPE mjahr,
belnr TYPE mblnr,
buzei TYPE mblpo,
END OF lty_ekbe.

DATA :            ls_goodsmvt_header TYPE bapi2017_gm_head_02,
lt_goodsmvt_items  TYPE TABLE OF bapi2017_gm_item_
lt_mat             TYPE TABLE OF yss_s_mat,
ls_mkpf            TYPE lty_mkpf,
lt_gr_item_temp    TYPE TABLE OF bapi2017_gm_item_
lt_t001l           TYPE TABLE OF lty_t001l,
lt_ekbe            TYPE TABLE OF lty_ekbe,
lv_ebeln           TYPE ebeln.

*Get Mjahr From Table To Pass In The BAPI
SELECT SINGLE mblnr
mjahr
xblnr
bktxt
FROM mkpf
INTO ls_mkpf
WHERE mblnr = im_gr_num.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>invalid_mat_doc_num
msgv1  = ycx_ss_exception=>format( im_gr_num ).
ELSE.
SELECT SINGLE ebeln FROM ekbe INTO lv_ebeln WHERE belnr =  im_gr_n
IF sy-subrc EQ 0.
SELECT ebeln
ebelp
zekkn
vgabe
gjahr
belnr
buzei
FROM ekbe
INTO TABLE lt_ekbe
WHERE ebeln = lv_ebeln.
IF sy-subrc EQ 0.
DELETE lt_ekbe WHERE vgabe NE '2'.
SORT lt_ekbe BY belnr DESCENDING.
DELETE ADJACENT DUPLICATES FROM lt_ekbe COMPARING ebeln.
ENDIF.

*** <<< START GANGADHAR20180509
* Fetch the KAD code and name
TRY.
CALL METHOD get_kad_code_n_name
EXPORTING
im_po_num       = lv_ebeln
IMPORTING
ex_cust_details = ex_cust_details.
CATCH ycx_ss_exception .
ENDTRY.
*** <<< END GANGADHAR20180509
ENDIF.
ENDIF.

*BAPI To Display Details For Material Document
CALL FUNCTION 'BAPI_GOODSMVT_GETDETAIL'
EXPORTING
materialdocument = im_gr_num
matdocumentyear  = ls_mkpf-mjahr
IMPORTING
goodsmvt_header  = ls_goodsmvt_header
TABLES
goodsmvt_items   = lt_goodsmvt_items
return           = ex_return.
*Pass Header Details To Output Structure
MOVE-CORRESPONDING ls_goodsmvt_header TO ex_gr_header.
IF ex_gr_header-header_txt IS INITIAL.
ex_gr_header-header_txt  = 'N/A'(005).
ENDIF.
ex_gr_header-deliv_no = ex_gr_header-deliv_note = ls_goodsmvt_header
READ TABLE lt_ekbe ASSIGNING FIELD-SYMBOL(<lfs_ekbe>) INDEX 1.
IF sy-subrc EQ 0.
ex_gr_header-pur_inv_id = <lfs_ekbe>-belnr.
ENDIF.

*for material description     ----------------------------
lt_gr_item_temp = lt_goodsmvt_items.
SORT lt_gr_item_temp BY material.
DELETE ADJACENT DUPLICATES FROM lt_gr_item_temp COMPARING material.
SELECT matnr
maktx
FROM makt
INTO TABLE lt_mat
FOR ALL ENTRIES IN lt_gr_item_temp
WHERE matnr = lt_gr_item_temp-material.
SORT lt_mat BY mat_num.
*                               ----------------------------
*for storage location description
SELECT werks
lgort
lgobe
INTO TABLE lt_t001l
FROM t001l FOR ALL ENTRIES IN lt_goodsmvt_items
WHERE werks = lt_goodsmvt_items-plant AND
lgort = lt_goodsmvt_items-stge_loc.
IF sy-subrc EQ 0.
SORT lt_t001l BY lgort.
ENDIF.
*Pass Item Details To Output Table
LOOP AT lt_goodsmvt_items ASSIGNING FIELD-SYMBOL(<lfs_goodsmvt_items
APPEND INITIAL LINE TO ex_gr_item ASSIGNING FIELD-SYMBOL(<lfs_gr_i
MOVE-CORRESPONDING <lfs_goodsmvt_items> TO <lfs_gr_item>.
*Material description
READ TABLE lt_mat ASSIGNING FIELD-SYMBOL(<lfs_mat>) WITH KEY mat_n
IF sy-subrc EQ 0.
<lfs_gr_item>-mat_desc = <lfs_mat>-mat_name.
ENDIF.
*storage location description
READ TABLE lt_t001l ASSIGNING FIELD-SYMBOL(<lfs_t001l>) WITH KEY l
IF sy-subrc EQ 0.
<lfs_gr_item>-stge_loc_desc = <lfs_t001l>-lgobe.
ENDIF.
ENDLOOP.
ENDMETHOD.
CANCEL_INCOMING_INVOICE
item
METHOD cancel_incoming_invoice.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Zareena Begum
* Created on  : 5th-April-2018
* Description : Cancel Incoming Invoice
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*
TYPES: BEGIN OF lty_rbkp,
belnr TYPE re_belnr,
gjahr TYPE gjahr,
END OF lty_rbkp.

DATA: ls_invoice_dets TYPE yss_s_invoice_num,
lt_rbkp         TYPE TABLE OF lty_rbkp,
ls_rbkp         TYPE lty_rbkp,
lt_return       TYPE bapiret2_tab.

IF im_invoice_dets IS NOT INITIAL.
SELECT belnr
gjahr FROM rbkp
INTO TABLE lt_rbkp
FOR ALL ENTRIES IN im_invoice_dets
WHERE belnr = im_invoice_dets-invoice_num AND
gjahr = im_invoice_dets-fiscal_year.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.
ENDIF.

LOOP AT lt_rbkp INTO ls_rbkp.
READ TABLE im_invoice_dets INTO ls_invoice_dets WITH KEY invoice_n
IF sy-subrc EQ 0.
ls_invoice_dets-reason_rev = '03'.
CALL FUNCTION 'BAPI_INCOMINGINVOICE_CANCEL'
EXPORTING
invoicedocnumber = ls_invoice_dets-invoice_num
fiscalyear       = ls_invoice_dets-fiscal_year
reasonreversal   = ls_invoice_dets-reason_rev
*           POSTINGDATE      =
* IMPORTING
*           INVOICEDOCNUMBER_REVERSAL       =
*           FISCALYEAR_REVERSAL             =
TABLES
return           = lt_return.

IF sy-subrc = 0.
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait = abap_true.
ENDIF.

APPEND LINES OF lt_return TO ex_return.
REFRESH lt_return.
ENDIF.
ENDLOOP.

ENDMETHOD.
CREATE_INCOMING_INVOICE
item
METHOD create_incoming_invoice.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Incresol Software Services Pvt. Ltd.
* Created on  : 11-April-2018
* Description : Create Incoming Invoice w.r.t Outbound Delivery
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*

*TYPES declarations
TYPES : BEGIN OF lty_ekpo,
ebeln TYPE ekpo-ebeln,
ebelp TYPE ekpo-ebelp,
ktmng TYPE ekpo-ktmng,
menge TYPE ekpo-menge,
meins TYPE ekpo-meins,
netwr TYPE ekpo-netwr,
mwskz TYPE ekpo-mwskz,
END OF lty_ekpo,

BEGIN OF lty_mkpf,
mblnr TYPE mkpf-mblnr,
mjahr TYPE mkpf-mjahr,
bldat TYPE mkpf-bldat,
xblnr TYPE mkpf-xblnr,
END OF lty_mkpf,

BEGIN OF lty_mseg,
mblnr   TYPE mseg-mblnr,
mjahr   TYPE mseg-mjahr,
zeile   TYPE mseg-zeile,
line_id TYPE mseg-line_id,
dmbtr   TYPE mseg-dmbtr,
menge   TYPE mseg-menge,
meins   TYPE mseg-meins,
ebeln   TYPE mseg-ebeln,
ebelp   TYPE mseg-ebelp,
smbln   TYPE mseg-smbln,
END OF lty_mseg,

BEGIN OF lty_a501,
kappl TYPE a501-kappl,
kschl TYPE a501-kschl,
aland TYPE a501-aland,
mwskz TYPE a501-mwskz,
kfrst TYPE a501-kfrst,
datbi TYPE a501-datbi,
datab TYPE a501-datab,
knumh TYPE a501-knumh,
END OF lty_a501,

BEGIN OF lty_konp,
knumh TYPE konp-knumh,
kschl TYPE konp-kschl,
kbetr TYPE konp-kbetr,
konwa TYPE konp-konwa,
END OF lty_konp,

BEGIN OF lty_rbkp,
belnr  TYPE re_belnr,
gjahr  TYPE gjahr,
bldat  TYPE bldat,
vgart  TYPE vgart,
lifnr  TYPE lifre,
rmwwr  TYPE rmwwr,
stblg  TYPE stblg,
rbstat TYPE rbstat,
END OF lty_rbkp,

BEGIN OF lty_rseg,
belnr	TYPE belnr_d,
gjahr	TYPE gjahr,
buzei	TYPE rblgp,
ebeln TYPE ebeln,
wrbtr TYPE wrbtr,
xblnr	TYPE xblnr1,
END OF lty_rseg.

TYPES : BEGIN OF lty_vbfa,
vbelv   TYPE vbfa-vbelv,
posnv   TYPE vbfa-posnv,
vbeln   TYPE vbfa-vbeln,
posnn   TYPE vbfa-posnn,
vbtyp_n TYPE vbfa-vbtyp_n,
vbtyp_v TYPE vbfa-vbtyp_v,
bwart   TYPE vbfa-bwart,
fktyp   TYPE vbfa-fktyp,
END OF lty_vbfa.

TYPES : BEGIN OF lty_vbrk,
vbeln TYPE vbrk-vbeln,
fksto TYPE vbrk-fksto,
knumv TYPE vbrk-knumv,
END OF lty_vbrk.

TYPES : BEGIN OF lty_vbrp,
vbeln TYPE vbrp-vbeln,
posnr TYPE vbrp-posnr,
fkimg TYPE vbrp-fkimg,
meins TYPE vbrp-meins,
netwr TYPE vbrp-netwr,
vgbel TYPE vbrp-vgbel,
vgpos TYPE vbrp-vgpos,
aubel TYPE vbrp-aubel,
aupos TYPE vbrp-aupos,
END OF lty_vbrp.

TYPES : BEGIN OF lt_lips,
vbeln TYPE lips-vbeln,
posnr TYPE lips-posnr,
lfimg TYPE lips-lfimg,
END OF lt_lips.

TYPES : BEGIN OF lty_gr,
ref_doc    TYPE lfbnr,
ref_doc_it TYPE posnr_nach,
END OF lty_gr.

TYPES : BEGIN OF lty_konv,
knumv TYPE konv-knumv,
kposn TYPE konv-kposn,
kschl TYPE konv-kschl,
kbetr TYPE konv-kbetr,
kwert TYPE konv-kwert,
END OF lty_konv.

DATA : lt_gr TYPE TABLE OF lty_gr,
ls_gr TYPE lty_gr.

DATA : lt_rbkp             TYPE TABLE OF lty_rbkp,
lt_rseg             TYPE TABLE OF lty_rseg,
ls_rbkp             TYPE lty_rbkp,
ls_rseg             TYPE lty_rseg,
ls_req_params       TYPE yss_s_req_params, "+++GANGADHAR20180
*Data Declarations
lt_mseg             TYPE TABLE OF lty_mseg,
ls_mseg             TYPE lty_mseg,
lt_mkpf             TYPE TABLE OF lty_mkpf,
ls_mkpf             TYPE lty_mkpf,
lt_ekpo             TYPE TABLE OF lty_ekpo,
ls_ekpo             TYPE lty_ekpo,
lt_a501             TYPE TABLE OF lty_a501,
ls_a501             TYPE lty_a501,
lt_konp             TYPE TABLE OF lty_konp,
ls_konp             TYPE lty_konp,
ls_header           TYPE bapi_incinv_create_header,
lt_item             TYPE STANDARD TABLE OF bapi_incinv_create
ls_item             TYPE bapi_incinv_create_item,
lv_invno            TYPE bapi_incinv_fld-inv_doc_no,
lv_fyear            TYPE bapi_incinv_fld-fisc_year,
lv_cnt              TYPE bapi_incinv_create_item-invoice_doc_
lt_vbfa             TYPE TABLE OF lty_vbfa,
lt_vbfa1            TYPE TABLE OF lty_vbfa,
lt_vbfa2            TYPE TABLE OF lty_vbfa,
lt_price            TYPE TABLE OF lty_vbfa,
ls_price            TYPE lty_vbfa,
ls_vbfa             TYPE lty_vbfa,
ls_vbfa1            TYPE lty_vbfa,
ls_vbfa2            TYPE lty_vbfa,
lv_vbeln            TYPE likp-vbeln,
ls_return           TYPE bapiret2,
lv_percent          TYPE konp-kbetr,
lv_percent1         TYPE konp-kbetr,
lv_tax              TYPE ekpo-netwr,
lv_tax1             TYPE ekpo-netwr,
lv_gross_amount     TYPE bapi_incinv_create_header-gross_amou
lv_gross_amount1    TYPE bapi_incinv_create_header-gross_amou
lt_accit            TYPE accit_t,
ls_accit            TYPE accit,
lt_accr             TYPE acccr_t,
lt_vbrk             TYPE TABLE OF lty_vbrk,
ls_vbrk             TYPE lty_vbrk,
lv_tabix            TYPE sy-tabix,
lt_vbrp             TYPE TABLE OF lty_vbrp,
ls_vbrp             TYPE lty_vbrp,
lv_vbrp_price       TYPE vbrp-netwr,
lv_ekpo_price       TYPE ekpo-netwr,
lv_price_difference TYPE konv-kwert,
lt_konv             TYPE TABLE OF lty_konv,
ls_konv             TYPE lty_konv.
DATA: lv_lifnr TYPE lifnr,
lv_bsart TYPE bsart.
*Add Leading Zero's
CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = im_vbeln
IMPORTING
output = lv_vbeln.

************************check for duplicate invoice create************++
IF im_action = yss_cl_type_pool=>yss_c_si OR im_action = yss_cl_type
SELECT belnr
gjahr
buzei
ebeln
wrbtr
xblnr
INTO TABLE lt_rseg FROM rseg WHERE xblnr = lv_vbeln .

IF lt_rseg IS NOT INITIAL.
SELECT  belnr
gjahr
bldat
vgart
lifnr
rmwwr
stblg
rbstat
FROM rbkp INTO TABLE lt_rbkp
FOR ALL ENTRIES IN lt_rseg
WHERE belnr = lt_rseg-belnr
and gjahr = lt_rseg-gjahr. "++++Added on 17/05/2019
LOOP AT lt_rbkp ASSIGNING FIELD-SYMBOL(<lfs_rbkp>).
IF <lfs_rbkp>-vgart EQ 'RD' AND
<lfs_rbkp>-stblg IS INITIAL.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>invoice_already_exist
msgv1  = ycx_ss_exception=>format( im_vbeln ).
ENDIF.
ENDLOOP.
ENDIF.
ENDIF.
**********************************************************************

*Sales Document Flow to get GR details
SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
bwart
fktyp
FROM vbfa
INTO TABLE lt_vbfa
WHERE vbelv = lv_vbeln
AND   vbtyp_n = 'i'
AND   vbtyp_v = yss_cl_type_pool=>yss_c_j
AND   bwart  = '102'.
IF sy-subrc = 0.
*Header: Material Document
SELECT mblnr
mjahr
bldat
xblnr
FROM mkpf
INTO TABLE lt_mkpf
FOR ALL ENTRIES IN lt_vbfa
WHERE mblnr EQ lt_vbfa-vbeln.
IF lt_mkpf IS NOT INITIAL.
*Document Segment: Material

SELECT mblnr
mjahr
zeile
line_id
dmbtr
menge
meins
ebeln
ebelp
smbln
FROM mseg
INTO TABLE lt_mseg
FOR ALL ENTRIES IN lt_mkpf
WHERE mblnr = lt_mkpf-mblnr
AND   mjahr = lt_mkpf-mjahr.
SORT lt_mseg BY smbln.
ENDIF.
ENDIF.

SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
bwart
fktyp
FROM vbfa
INTO TABLE lt_vbfa1
WHERE vbelv = lv_vbeln
AND   vbtyp_v IN (yss_cl_type_pool=>yss_c_j , yss_cl_type_poo
AND   fktyp  = 'I'.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>no_billing_details.
ENDIF.

SELECT vbeln
fksto
knumv
FROM vbrk
INTO TABLE lt_vbrk
FOR ALL ENTRIES IN lt_vbfa1
WHERE vbeln = lt_vbfa1-vbeln
AND   fksto = space.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.

SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
bwart
fktyp
FROM vbfa
INTO TABLE lt_vbfa2
FOR ALL ENTRIES IN lt_vbfa1
WHERE vbelv = lt_vbfa1-vbelv
AND   posnv = lt_vbfa1-posnv
AND   vbtyp_n = 'i'
AND   vbtyp_v IN (yss_cl_type_pool=>yss_c_j,yss_cl_type_pool=
AND   bwart   IN ('101','161').
IF sy-subrc = 0.
IF lt_mseg IS NOT INITIAL.
LOOP AT lt_vbfa2 INTO ls_vbfa2.
lv_tabix = sy-tabix.
READ TABLE lt_mseg INTO ls_mseg WITH KEY smbln = ls_vbfa2-vbel
IF sy-subrc = 0.
DELETE lt_vbfa2 INDEX lv_tabix.
ENDIF.
***          IF ls_vbfa2-vbtyp_v EQ yss_cl_type_pool=>yss_c_t.  " For Re
***            ls_header-inv_tran = '2'.
***          ENDIF.
CLEAR : ls_vbfa2,ls_mseg,lv_tabix.
ENDLOOP.

IF lt_vbfa2 IS INITIAL.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>no_gr_found
msgv1  = ycx_ss_exception=>format( im_vbeln ).
ENDIF.
ENDIF.

*Header: Material Document
REFRESH : lt_mkpf,lt_mseg.
SELECT mblnr
mjahr
bldat
xblnr
FROM mkpf
INTO TABLE lt_mkpf
FOR ALL ENTRIES IN lt_vbfa2
WHERE mblnr EQ lt_vbfa2-vbeln.
IF sy-subrc = 0.
*Document Segment: Material
SELECT mblnr
mjahr
zeile
line_id
dmbtr
menge
meins
ebeln
ebelp
smbln
FROM mseg
INTO TABLE lt_mseg
FOR ALL ENTRIES IN lt_mkpf
WHERE mblnr = lt_mkpf-mblnr
AND   mjahr = lt_mkpf-mjahr.
IF sy-subrc = 0.
SORT lt_mseg BY ebeln ebelp.
ENDIF.
ENDIF.
ENDIF.

*Purchasing Document Item

IF lt_mseg IS NOT INITIAL.
READ TABLE lt_mseg INTO ls_mseg INDEX 1.
IF sy-subrc EQ 0.
SELECT SINGLE lifnr bsart FROM ekko
INTO (lv_lifnr, lv_bsart) WHERE ebeln EQ ls_mseg-ebeln.
IF sy-subrc EQ 0.
*            Do nothing
ENDIF.
ENDIF.
SELECT ebeln
ebelp
ktmng
menge
meins
netwr
mwskz
FROM ekpo
INTO TABLE lt_ekpo
FOR ALL ENTRIES IN lt_mseg
WHERE ebeln = lt_mseg-ebeln
AND   ebelp = lt_mseg-ebelp.
IF sy-subrc = 0.
SORT lt_ekpo BY ebeln ebelp.
ENDIF.

ENDIF.
IF lt_ekpo IS NOT INITIAL.
SELECT kappl
kschl
aland
mwskz
kfrst
datbi
datab
knumh
FROM a501
INTO TABLE lt_a501
FOR ALL ENTRIES IN lt_ekpo
WHERE kappl = 'TX'
AND   kschl IN ('JICG','JISG','JIUG','JIIG')
AND   mwskz = lt_ekpo-mwskz
AND   datbi GE im_posting_date
AND   datab LE im_posting_date.

IF sy-subrc = 0.
SORT lt_a501 BY mwskz.

SELECT knumh
kschl
kbetr
konwa
FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_a501
WHERE knumh = lt_a501-knumh
AND   kschl = lt_a501-kschl.
IF sy-subrc = 0.
SORT lt_konp BY knumh kschl.
ENDIF.
ENDIF.
ENDIF.

*Billig Header
SORT lt_vbrk BY vbeln DESCENDING.
READ TABLE lt_vbrk INTO ls_vbrk INDEX 1.
IF sy-subrc = 0." AND ls_vbrk-knumv IS NOT INITIAL.
*      SELECT knumv
*             kposn
*             kschl
*             kwert
*             FROM konv
*             INTO TABLE lt_konv
*             WHERE knumv = ls_vbrk-knumv
*             AND   kschl IN ('ZSPE','ZSVL','ZPER','ZVAL').
*      IF sy-subrc = 0.
*        SORT lt_konv BY knumv kposn.
*      ENDIF.
ENDIF.
*Header Data
IF lv_bsart NE 'ZRN'.
ls_header-invoice_ind  = abap_true.                    "Enter Invo
ENDIF.
ls_header-doc_date     = im_document_date.             "Enter the do
ls_header-pstng_date   = im_posting_date.              "Enter the po
ls_header-comp_code    = yss_cl_type_pool=>yss_c_rmss. "Enter Compan
ls_header-calc_tax_ind = abap_true.                    "Enter Calcul
ls_header-bline_date   = im_baseline_date.             "Enter Base L
ls_header-currency     = 'INR'.                        "Enter Curren
ls_header-bus_area     = im_werks.                     "Enter Busine
ls_header-header_txt   = im_header_text.               "Enter Header
ls_header-pmnttrms     = yss_cl_type_pool=>yss_c_0001. "Enter paymen
ls_header-ref_doc_no   = ls_vbrk-vbeln.                "Enter Billin

*Item Data
LOOP AT lt_mseg INTO ls_mseg.
*GR Item Details
lv_cnt = lv_cnt + 1.
ls_item-invoice_doc_item = lv_cnt.
ls_item-ref_doc      = ls_mseg-mblnr.    "Enter the GR number
ls_item-ref_doc_year = ls_mseg-mjahr.    "Enter the GR fiscal year
ls_item-ref_doc_it   = ls_mseg-zeile.    "Enter the GR item number
ls_item-quantity     = ls_mseg-menge.    "Enter the invoice quanti
ls_item-po_unit      = ls_mseg-meins.    "Enter the UoM

*GR item data
READ TABLE lt_ekpo INTO ls_ekpo WITH KEY ebeln = ls_mseg-ebeln ebe
IF sy-subrc = 0.
*PO item data
ls_item-po_number        = ls_ekpo-ebeln.    "Enter the PO numbe
ls_item-po_item          = ls_ekpo-ebelp.    "Enter the PO item
ls_item-tax_code         = ls_ekpo-mwskz.    "Enter the tax code
ENDIF.
APPEND ls_item TO lt_item.
* Logic for Price
*For GR No and GR Item No Structure
ls_gr-ref_doc    = ls_item-ref_doc.
ls_gr-ref_doc_it = ls_item-ref_doc_it.
APPEND ls_gr TO lt_gr.
CLEAR : ls_item,ls_gr,ls_ekpo,ls_mseg.
ENDLOOP.

**** Logic for Price
****For GR No and GR Item No Structure
***    LOOP AT lt_item INTO ls_item.
***      ls_gr-ref_doc    = ls_item-ref_doc.
***      ls_gr-ref_doc_it = ls_item-ref_doc_it.
***      APPEND ls_gr TO lt_gr.
***      CLEAR : ls_item,ls_gr.
***    ENDLOOP.

IF lt_gr IS NOT INITIAL.
SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
bwart
fktyp
FROM vbfa
INTO TABLE lt_price
FOR ALL ENTRIES IN lt_gr
WHERE vbelv = lv_vbeln
AND   vbeln = lt_gr-ref_doc
AND   posnn = lt_gr-ref_doc_it
AND   vbtyp_v IN (yss_cl_type_pool=>yss_c_j,yss_cl_type_poo
IF lt_price IS NOT INITIAL.
SORT lt_price BY vbelv vbeln posnn.
SELECT vbeln
posnr
fkimg
meins
netwr
vgbel
vgpos
aubel
aupos
FROM vbrp
INTO TABLE lt_vbrp
FOR ALL ENTRIES IN lt_price
WHERE vbeln = ls_vbrk-vbeln
AND   vgbel = lt_price-vbelv
AND   vgpos = lt_price-posnv.
IF sy-subrc = 0.
SORT lt_vbrp BY vbeln vgbel vgpos.
ENDIF.
ENDIF.
ENDIF.

*Price
LOOP AT lt_item INTO ls_item.

READ TABLE lt_price INTO ls_price WITH KEY vbelv = lv_vbeln
vbeln = ls_item-ref_doc
posnn = ls_item-ref_doc
IF sy-subrc = 0.
READ TABLE lt_vbrp INTO ls_vbrp WITH KEY vbeln = ls_vbrk-vbeln
vgbel = ls_price-vbelv
vgpos = ls_price-posnv
IF sy-subrc = 0.
ls_item-item_amount  = ls_vbrp-netwr.    "Enter the item amoun

*Total Amount with Tax
LOOP AT lt_a501 INTO ls_a501 WHERE mwskz = ls_item-tax_code.
LOOP AT lt_konp INTO ls_konp WHERE knumh = ls_a501-knumh AND
lv_percent = ls_konp-kbetr / 10.
lv_tax  =  lv_tax + ls_vbrp-netwr * lv_percent / 100.
CLEAR : lv_percent,ls_konp.
ENDLOOP.
ENDLOOP.
*Gross Amount
lv_gross_amount = lv_gross_amount + ls_vbrp-netwr + lv_tax.
MODIFY lt_item FROM ls_item TRANSPORTING item_amount.
ENDIF.
ENDIF.
CLEAR : ls_item,ls_price,ls_vbrp,ls_a501,ls_konp,lv_percent,lv_tax
ENDLOOP.

"Enter the gross amount(aft. tax) for the invoice
ls_header-gross_amount = lv_gross_amount.

* Based on action given processing happens
CASE im_action.
WHEN yss_cl_type_pool=>yss_c_si.
*Simulate
ex_header = ls_header.
ex_item   = lt_item.
CALL FUNCTION 'MRM_SRM_INVOICE_SIMULATE'
EXPORTING
headerdata = ex_header
IMPORTING
return     = ex_return
t_accit    = lt_accit
t_acccr    = lt_accr
TABLES
itemdata   = ex_item.
****<<<< Commented By Abhishek 22/10/2018 +++ Price Difference Issue
**        IF lt_accit IS NOT INITIAL.
**          SORT lt_accit BY ktosl.
**          DELETE lt_accit WHERE ktosl NE 'EIN'.
**          LOOP AT lt_accit INTO ls_accit.
**            lv_price_difference = lv_price_difference + ls_accit-pswbt
**            CLEAR : ls_accit.
**          ENDLOOP.
***Price difference amount
**          ex_price_difference = lv_price_difference.
**        ENDIF.
****>>>>>>>>>>>>>>>>>>End
*Get Simulated Data
CALL METHOD yss_cl_mm_process=>simulate_delivery_for_invoice
EXPORTING
im_vbeln           = lv_vbeln
im_posting_date    = im_posting_date
IMPORTING
ex_calculated_data = ex_calculated_data.
***<<<<<<Added by Abhishek  22/10/2018
LOOP AT ex_calculated_data ASSIGNING FIELD-SYMBOL(<lfs_cal_data>
ex_price_difference = ex_price_difference + <lfs_cal_data>-dis
ENDLOOP.
**>>>>>>End  22/10/2018
*** >>> START GANGADHAR20180510
* To fetch the vendor details
ls_req_params-werks = im_werks.
IF lv_lifnr IS NOT INITIAL.
CALL METHOD yss_cl_mm_process=>fetch_vendor_details
EXPORTING
im_req_params     = ls_req_params
im_vendor         = lv_lifnr
IMPORTING
ex_vendor_details = ex_vendor_details.
ENDIF.

*** <<< END GANGADHAR20180510
WHEN yss_cl_type_pool=>yss_c_ci.
*Bapi to Create Purchase Invoice
CALL FUNCTION 'BAPI_INCOMINGINVOICE_CREATE'
EXPORTING
headerdata       = ls_header
IMPORTING
invoicedocnumber = lv_invno
fiscalyear       = lv_fyear
TABLES
itemdata         = lt_item
return           = ex_return.
IF lv_invno IS NOT INITIAL AND lv_fyear IS NOT INITIAL.
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait = abap_true.
ls_return-message_v1 = lv_invno.
ls_return-message_v2 = lv_fyear.
ls_return-message    = 'The Invoice is Created'.
ls_return-type       = 'I'.
ls_return-number     = '001'.
APPEND ls_return TO ex_return.
ENDIF.
ENDCASE.
ENDMETHOD.
SIMULATE_DELIVERY_FOR_INVOICE
item
METHOD simulate_delivery_for_invoice.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Incresol Software Services Pvt. Ltd.
* Created on  : 13-April-2018
* Description : Simulate Delivery for Calculated Data
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*

*Types Declarations
TYPES : BEGIN OF lty_ekko,
ebeln TYPE ekko-ebeln,
bukrs TYPE ekko-bukrs,
knumv TYPE ekko-knumv,
END OF lty_ekko.

TYPES : BEGIN OF lty_ekpo,
ebeln TYPE ekpo-ebeln,
ebelp TYPE ekpo-ebelp,
txz01 TYPE ekpo-txz01,
matnr TYPE ekpo-matnr,
menge TYPE ekpo-menge,
meins TYPE ekpo-meins,
netpr TYPE ekpo-netpr,
netwr TYPE ekpo-netwr,
mwskz TYPE ekpo-mwskz,
END OF lty_ekpo.

TYPES : BEGIN OF lty_konv,
knumv TYPE konv-knumv,
kposn TYPE konv-kposn,
kschl TYPE konv-kschl,
kbetr TYPE konv-kbetr,
waers TYPE konv-waers,
kwert TYPE konv-kwert,
END OF lty_konv.

TYPES :       BEGIN OF lty_mseg,
mblnr   TYPE mseg-mblnr,
mjahr   TYPE mseg-mjahr,
zeile   TYPE mseg-zeile,
line_id TYPE mseg-line_id,
dmbtr   TYPE mseg-dmbtr,
menge   TYPE mseg-menge,
meins   TYPE mseg-meins,
ebeln   TYPE mseg-ebeln,
ebelp   TYPE mseg-ebelp,
smbln   TYPE mseg-smbln,
END OF lty_mseg.

TYPES :      BEGIN OF lty_mkpf,
mblnr TYPE mkpf-mblnr,
mjahr TYPE mkpf-mjahr,
bldat TYPE mkpf-bldat,
xblnr TYPE mkpf-xblnr,
END OF lty_mkpf.

TYPES : BEGIN OF lty_vbfa,
vbelv   TYPE vbfa-vbelv,
posnv   TYPE vbfa-posnv,
vbeln   TYPE vbfa-vbeln,
posnn   TYPE vbfa-posnn,
vbtyp_n TYPE vbfa-vbtyp_n,
vbtyp_v TYPE vbfa-vbtyp_v,
bwart   TYPE vbfa-bwart,
fktyp   TYPE vbfa-fktyp,
END OF lty_vbfa.

TYPES : BEGIN OF lty_vbrk,
vbeln TYPE vbrk-vbeln,
fkart TYPE vbrk-fkart,
fksto TYPE vbrk-fksto,
knumv TYPE vbrk-knumv,
END OF lty_vbrk.

TYPES : BEGIN OF lty_vbrp,
vbeln TYPE vbrp-vbeln,
posnr TYPE vbrp-posnr,
fkimg TYPE vbrp-fkimg,
meins TYPE vbrp-meins,
netwr TYPE vbrp-netwr,
vgbel TYPE vbrp-vgbel,
vgpos TYPE vbrp-vgpos,
aubel TYPE vbrp-aubel,
aupos TYPE vbrp-aupos,
END OF lty_vbrp.

TYPES : BEGIN OF lty_a501,
kappl TYPE a501-kappl,
kschl TYPE a501-kschl,
aland TYPE a501-aland,
mwskz TYPE a501-mwskz,
kfrst TYPE a501-kfrst,
datbi TYPE a501-datbi,
datab TYPE a501-datab,
knumh TYPE a501-knumh,
END OF lty_a501.

TYPES : BEGIN OF lty_gr,
ref_doc    TYPE lfbnr,
ref_doc_it TYPE posnr_nach,
END OF lty_gr.

TYPES :  BEGIN OF lty_konp,
knumh TYPE konp-knumh,
kschl TYPE konp-kschl,
kbetr TYPE konp-kbetr,
konwa TYPE konp-konwa,
END OF lty_konp.

DATA : lt_gr TYPE TABLE OF lty_gr,
ls_gr TYPE lty_gr.

* Data Declarations
DATA :   lt_ekpo  TYPE TABLE OF lty_ekpo,
ls_ekpo  TYPE lty_ekpo,
lt_ekko  TYPE TABLE OF lty_ekko,
ls_ekko  TYPE lty_ekko,
lt_konv  TYPE TABLE OF lty_konv,
ls_konv  TYPE lty_konv,
lv_vbeln TYPE likp-vbeln,
ls_data  TYPE yss_s_delv_simulate,
lt_mseg  TYPE TABLE OF lty_mseg,
ls_mseg  TYPE lty_mseg,
lt_mkpf  TYPE TABLE OF lty_mkpf,
ls_mkpf  TYPE lty_mkpf,
lt_vbfa  TYPE TABLE OF lty_vbfa,
lt_vbfa1 TYPE TABLE OF lty_vbfa,
lt_vbfa2 TYPE TABLE OF lty_vbfa,
ls_vbfa  TYPE lty_vbfa,
ls_vbfa1 TYPE lty_vbfa,
ls_vbfa2 TYPE lty_vbfa,
lt_price TYPE TABLE OF lty_vbfa,
ls_price TYPE lty_vbfa,
lt_vbrk  TYPE TABLE OF lty_vbrk,
ls_vbrk  TYPE lty_vbrk,
lv_tabix TYPE sy-tabix,
lt_vbrp  TYPE TABLE OF lty_vbrp,
ls_vbrp  TYPE lty_vbrp,
lt_a501  TYPE TABLE OF lty_a501,
ls_a501  TYPE lty_a501,
lt_konp  TYPE TABLE OF lty_konp,
ls_konp  TYPE lty_konp.

*Add Leading Zero's
CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = im_vbeln
IMPORTING
output = lv_vbeln.
*Sales Document Flow to get GR details
SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
bwart
fktyp
FROM vbfa
INTO TABLE lt_vbfa
WHERE vbelv = lv_vbeln
AND   vbtyp_n = 'i'
AND   vbtyp_v = yss_cl_type_pool=>yss_c_j
AND   bwart  = '102'.
IF sy-subrc = 0.
*Header: Material Document
SELECT mblnr
mjahr
bldat
xblnr
FROM mkpf
INTO TABLE lt_mkpf
FOR ALL ENTRIES IN lt_vbfa
WHERE mblnr EQ lt_vbfa-vbeln.
IF sy-subrc = 0.
*Document Segment: Material
SELECT mblnr
mjahr
zeile
line_id
dmbtr
menge
meins
ebeln
ebelp
smbln
FROM mseg
INTO TABLE lt_mseg
FOR ALL ENTRIES IN lt_mkpf
WHERE mblnr = lt_mkpf-mblnr
AND   mjahr = lt_mkpf-mjahr.
SORT lt_mseg BY smbln.
ENDIF.
ENDIF.

SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
bwart
fktyp
FROM vbfa
INTO TABLE lt_vbfa1
WHERE vbelv = lv_vbeln
AND   vbtyp_v IN (yss_cl_type_pool=>yss_c_j,yss_cl_type_pool=
AND   fktyp  = 'I'.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.
SELECT vbeln
fkart
fksto
knumv     "+++GANGADHAR20180612
FROM vbrk
INTO TABLE lt_vbrk
FOR ALL ENTRIES IN lt_vbfa1
WHERE vbeln = lt_vbfa1-vbeln
AND   fkart IN ( 'ZIV', 'ZNCR' )
AND   fksto = space.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.

*** >>> START GANGADHAR20180612
* To get the discount value at item level
*Get tax amounts from Conditions table
SELECT knumv
kposn
kschl
kbetr
waers
kwert
FROM konv
INTO TABLE lt_konv
FOR ALL ENTRIES IN lt_vbrk
WHERE knumv = lt_vbrk-knumv
AND   kschl IN ('ZSPE','ZSVL','ZPER','ZVAL','ZPRO').
IF sy-subrc = 0.
SORT lt_konv BY knumv kposn.
ENDIF.

*** <<< END GANGADHAR20180612

SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
bwart
fktyp
FROM vbfa
INTO TABLE lt_vbfa2
FOR ALL ENTRIES IN lt_vbfa1
WHERE vbelv = lt_vbfa1-vbelv
AND   posnv = lt_vbfa1-posnv
AND   vbtyp_n = 'i'
AND   vbtyp_v IN (yss_cl_type_pool=>yss_c_j,yss_cl_type_pool=
AND   bwart   IN ('101','161').
IF sy-subrc = 0.
IF lt_mseg IS NOT INITIAL.
LOOP AT lt_vbfa2 INTO ls_vbfa2.
lv_tabix = sy-tabix.
READ TABLE lt_mseg INTO ls_mseg WITH KEY smbln = ls_vbfa2-vbel
IF sy-subrc = 0.
DELETE lt_vbfa2 INDEX lv_tabix.
ENDIF.
CLEAR : ls_vbfa2,ls_mseg,lv_tabix.
ENDLOOP.
ENDIF.

*Header: Material Document
REFRESH : lt_mkpf,lt_mseg.
SELECT mblnr
mjahr
bldat
xblnr
FROM mkpf
INTO TABLE lt_mkpf
FOR ALL ENTRIES IN lt_vbfa2
WHERE mblnr EQ lt_vbfa2-vbeln.
IF sy-subrc = 0.
SORT lt_mkpf BY mblnr mjahr.
*Document Segment: Material
SELECT mblnr
mjahr
zeile
line_id
dmbtr
menge
meins
ebeln
ebelp
smbln
FROM mseg
INTO TABLE lt_mseg
FOR ALL ENTRIES IN lt_mkpf
WHERE mblnr = lt_mkpf-mblnr
AND   mjahr = lt_mkpf-mjahr.
IF sy-subrc = 0.
SORT lt_mseg BY ebeln ebelp.
ENDIF.
ENDIF.
ENDIF.

*Purchasing Document Header
IF lt_mseg IS NOT INITIAL.
SELECT ebeln
bukrs
knumv
FROM ekko
INTO TABLE lt_ekko
FOR ALL ENTRIES IN lt_mseg
WHERE ebeln = lt_mseg-ebeln.
IF lt_ekko IS NOT INITIAL.
****Conditions (Transaction Data)
***        SELECT knumv
***               kposn
***               kschl
***               kbetr
***               waers
***               kwert
***               FROM konv
***               INTO TABLE lt_konv
***               FOR ALL ENTRIES IN lt_ekko
***               WHERE knumv = lt_ekko-knumv
***               AND   kschl IN (yss_cl_type_pool=>yss_c_jicg,yss_cl_ty
***        IF sy-subrc = 0.
***          SORT lt_konv BY knumv kschl.
***        ENDIF.
ENDIF.
*PO Item Data
SELECT ebeln
ebelp
txz01
matnr
menge
meins
netpr
netwr
mwskz
FROM ekpo
INTO TABLE lt_ekpo
FOR ALL ENTRIES IN lt_mseg
WHERE ebeln = lt_mseg-ebeln
AND   ebelp = lt_mseg-ebelp.
IF sy-subrc = 0.
SORT lt_ekpo BY ebeln ebelp.

SELECT kappl
kschl
aland
mwskz
kfrst
datbi
datab
knumh
FROM a501
INTO TABLE lt_a501
FOR ALL ENTRIES IN lt_ekpo
WHERE kappl = 'TX'
AND   kschl IN ('JICG','JISG','JIUG','JIIG')
AND   mwskz = lt_ekpo-mwskz
AND   datbi GE im_posting_date
AND   datab LE im_posting_date.
IF sy-subrc = 0.
SORT lt_a501 BY mwskz.

SELECT knumh
kschl
kbetr
konwa
FROM konp
INTO TABLE lt_konp
FOR ALL ENTRIES IN lt_a501
WHERE knumh = lt_a501-knumh
AND   kschl = lt_a501-kschl.
IF sy-subrc = 0.
SORT lt_konp BY knumh kschl.
ENDIF.
ENDIF.
ENDIF.
ENDIF.

* Get the delivery date
SELECT SINGLE bldat FROM likp INTO @DATA(lv_dlv_date) WHERE vbeln =
IF sy-subrc EQ 0.

ENDIF.
READ TABLE lt_ekko INTO ls_ekko INDEX 1.
IF sy-subrc = 0.
"Do Nothing
ENDIF.

SORT lt_vbrk BY fkart DESCENDING.
READ TABLE lt_vbrk INTO ls_vbrk INDEX 1.
IF sy-subrc = 0.
"Do Nothing
ENDIF.

*Item Data
LOOP AT lt_mseg INTO ls_mseg.
*Quantity
ls_data-quantity       = ls_mseg-menge.
*UOM
ls_data-uom            = ls_mseg-meins.
*GR No
ls_data-gr_no          = ls_mseg-mblnr.
*GR Item No
ls_data-gr_item_no     = ls_mseg-zeile.

READ TABLE lt_mkpf INTO ls_mkpf WITH KEY mblnr = ls_mseg-mblnr mja
IF sy-subrc EQ 0.
ls_data-gr_date = ls_mkpf-bldat.
ENDIF.

READ TABLE lt_ekpo INTO ls_ekpo WITH KEY ebeln = ls_mseg-ebeln ebe
IF sy-subrc = 0.
*PO No
ls_data-po_no          = ls_ekpo-ebeln.
*PO Item No
ls_data-po_item_no     = ls_ekpo-ebelp.
*Material Code
ls_data-material_code  = ls_ekpo-matnr.
*Material Descp
ls_data-material_name  = ls_ekpo-txz01.
*Tax Code
ls_data-tax_code       = ls_ekpo-mwskz.
ENDIF.
*Delivery Note
ls_data-delivery_no      = lv_vbeln.
*Delivery date
ls_data-dlv_date         = lv_dlv_date.

APPEND ls_data TO ex_calculated_data.
****For GR No and GR Item No Structure
ls_gr-ref_doc    = ls_data-gr_no.
ls_gr-ref_doc_it = ls_data-gr_item_no.
APPEND ls_gr TO lt_gr.
CLEAR : ls_data,ls_gr,ls_ekpo,ls_mseg.
ENDLOOP.

****For GR No and GR Item No Structure
***    LOOP AT ex_calculated_data INTO ls_data.
***      ls_gr-ref_doc    = ls_data-gr_no.
***      ls_gr-ref_doc_it = ls_data-gr_item_no.
***      APPEND ls_gr TO lt_gr.
***      CLEAR : ls_data,ls_gr.
***    ENDLOOP.

IF lt_gr IS NOT INITIAL.
SELECT vbelv
posnv
vbeln
posnn
vbtyp_n
vbtyp_v
bwart
fktyp
FROM vbfa
INTO TABLE lt_price
FOR ALL ENTRIES IN lt_gr
WHERE vbelv = lv_vbeln
AND   vbeln = lt_gr-ref_doc
AND   posnn = lt_gr-ref_doc_it
AND   vbtyp_v IN (yss_cl_type_pool=>yss_c_j,yss_cl_type_poo
IF lt_price IS NOT INITIAL.
SORT lt_price BY vbelv vbeln posnn.
SELECT vbeln
posnr
fkimg
meins
netwr
vgbel
vgpos
aubel
aupos
FROM vbrp
INTO TABLE lt_vbrp
FOR ALL ENTRIES IN lt_price
WHERE vbeln = ls_vbrk-vbeln
AND   vgbel = lt_price-vbelv
AND   vgpos = lt_price-posnv.
IF sy-subrc = 0.
SORT lt_vbrp BY vbeln vgbel vgpos.
ENDIF.
ENDIF.
ENDIF.


LOOP AT ex_calculated_data INTO ls_data.

READ TABLE lt_price INTO ls_price WITH KEY vbelv = lv_vbeln
vbeln = ls_data-gr_no
posnn = ls_data-gr_item
IF sy-subrc = 0.
READ TABLE lt_vbrp INTO ls_vbrp WITH KEY vbeln = ls_vbrk-vbeln
vgbel = ls_price-vbelv
vgpos = ls_price-posnv
IF sy-subrc = 0.
ls_data-value  = ls_vbrp-netwr.    "Enter the item amount

*Total Amount with Tax
LOOP AT lt_a501 INTO ls_a501 WHERE mwskz = ls_data-tax_code.
LOOP AT lt_konp INTO ls_konp WHERE knumh = ls_a501-knumh AND
CASE ls_konp-kschl.
*CGST Rate & CGST Amt
WHEN yss_cl_type_pool=>yss_c_jicg.
IF ls_konp-kbetr IS NOT INITIAL.
ls_data-cgst_rate = ls_konp-kbetr / 10.
ls_data-cgst_amt  = ls_vbrp-netwr * ls_data-cgst_rat
ENDIF.
*SGST/UTGST Rate & SGST/UTGST Amt
WHEN yss_cl_type_pool=>yss_c_jisg OR yss_cl_type_pool=>y
IF ls_konp-kbetr IS NOT INITIAL.
ls_data-sgst_rate = ls_konp-kbetr / 10.
ls_data-sgst_amt  = ls_vbrp-netwr * ls_data-sgst_rat
ENDIF.
*IGST Rate & IGST Amt
WHEN yss_cl_type_pool=>yss_c_jiig.
IF ls_konp-kbetr IS NOT INITIAL.
ls_data-igst_rate = ls_konp-kbetr / 10.
ls_data-igst_amt  = ls_vbrp-netwr * ls_data-igst_rat
ENDIF.
ENDCASE.
CLEAR : ls_konp.
ENDLOOP.
CLEAR : ls_a501.
ENDLOOP.
* For Discount and Price difference +++GANGADHAR20180531 >>>
*      READ TABLE lt_vbrp INTO DATA(ls_vbrp) WITH KEY aubel = <lfs_taxic
*                                                      aupos = <lfs_taxi
*      IF sy-subrc EQ 0.
READ TABLE lt_konv WITH KEY knumv = ls_vbrk-knumv kposn = ls_v
IF sy-subrc EQ 0.
DATA(lv_index) = sy-tabix.
LOOP AT lt_konv INTO ls_konv FROM lv_index.
IF ls_konv-knumv NE ls_vbrk-knumv OR ls_konv-kposn NE ls_v
EXIT.
ENDIF.
*BASE price determination
CASE ls_konv-kschl.
WHEN 'ZPRO'.
ls_data-base_value = ls_konv-kwert.
*UNIT price
ls_data-unit_price = ls_konv-kbetr.
WHEN 'ZPER' OR 'ZVAL' OR 'ZSPE' OR 'ZSVL'.
*Discount value
ls_data-discount_value   = ls_data-discount_value + ls
WHEN OTHERS.
ENDCASE.
ENDLOOP.
ENDIF.
*      ENDIF.
*** <<< END GANGADHAR20180531

*Net Amount
ls_data-net_amount = ls_vbrp-netwr + ls_data-cgst_amt + ls_dat
MODIFY ex_calculated_data FROM ls_data TRANSPORTING value cgst
base_value
ENDIF.
ENDIF.
CLEAR : ls_data,ls_price,ls_vbrp.
ENDLOOP.
ENDMETHOD.
GET_KAD_CODE_N_NAME
item
METHOD get_kad_code_n_name.
TYPES : BEGIN OF lty_ref_num,
ebeln TYPE ebeln,
ihrez TYPE ihrez,
kunnr TYPE kunnr,
END OF lty_ref_num.

DATA : lv_code    TYPE kunnr,
lt_kna1    TYPE STANDARD TABLE OF yss_s_cust,
lt_ref_num TYPE STANDARD TABLE OF lty_ref_num.

IF im_po_num IS SUPPLIED.
* Fetch the reference num
SELECT SINGLE ihrez FROM ekko
INTO ex_cust_details-cust_id
WHERE ebeln EQ im_po_num.
IF sy-subrc NE 0.
RETURN.
*      RAISE EXCEPTION TYPE ycx_ss_exception
*        EXPORTING
*          textid = ycx_ss_exception=>po_not_found.
ENDIF.

CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = ex_cust_details-cust_id
IMPORTING
output = lv_code.

* Based on the Reference num get the name
SELECT SINGLE name1 FROM kna1 INTO ex_cust_details-cust_name
WHERE kunnr EQ lv_code.
IF sy-subrc EQ 0.
* Do nothing
ENDIF.
ENDIF.


IF im_po_list IS SUPPLIED AND im_po_list IS NOT INITIAL.
* Fetch the reference num
SELECT ebeln ihrez FROM ekko
INTO TABLE lt_ref_num
FOR ALL ENTRIES IN im_po_list
WHERE ebeln EQ im_po_list-ebeln.
IF sy-subrc NE 0.
RETURN.
*      RAISE EXCEPTION TYPE ycx_ss_exception
*        EXPORTING
*          textid = ycx_ss_exception=>po_not_found.
ENDIF.

LOOP AT lt_ref_num ASSIGNING FIELD-SYMBOL(<lfs_ref_num>).
CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = <lfs_ref_num>-ihrez
IMPORTING
output = <lfs_ref_num>-kunnr.
ENDLOOP.

* Based on the Reference num get the name
IF lt_ref_num IS NOT INITIAL.
SELECT kunnr name1 FROM kna1 INTO TABLE lt_kna1
FOR ALL ENTRIES IN lt_ref_num
WHERE kunnr EQ lt_ref_num-kunnr.
IF sy-subrc EQ 0.
* Do nothing
ENDIF.
ENDIF.

LOOP AT im_po_list INTO DATA(lwa_po_list).
APPEND INITIAL LINE TO ex_cust_list ASSIGNING FIELD-SYMBOL(<lfs_
<lfs_cust_list>-po_num = lwa_po_list-ebeln.
READ TABLE lt_ref_num INTO DATA(ls_ref_num) WITH KEY ebeln = lwa
IF sy-subrc EQ 0.
READ TABLE lt_kna1 INTO DATA(ls_kna1) WITH KEY cust_id = ls_re
IF sy-subrc EQ 0.
<lfs_cust_list>-cust_id   = ls_kna1-cust_id.
<lfs_cust_list>-cust_name = ls_kna1-cust_name.
ENDIF.
ENDIF.
ENDLOOP.
ENDIF.

ENDMETHOD.
GET_OUTGOING_PAYMENT_DETAILS
item
METHOD get_outgoing_payment_details.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Incresol Software Services Pvt. Ltd.
* Created on  : 15-May-2018
* Description : Get Incoming Payment Details
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*

*Types Declarations
TYPES : BEGIN OF t_tab,
sample_value(30) TYPE c,
END OF t_tab.

*Data Declarations
DATA : lt_ftpost       TYPE TABLE OF ftpost,
lt_blntab       TYPE TABLE OF blntab,
lt_fttax        TYPE TABLE OF fttax,
i_tab           TYPE STANDARD TABLE OF t_tab,
ls_ftpost       TYPE ftpost,
ls_blntab       TYPE blntab,
ls_fttax        TYPE fttax,
lv_bldat(10),
lv_budat(10),
lv_wrbtr(30),
wa_tab          TYPE t_tab,
lv_dcpfm        TYPE usr01-dcpfm,
lv_whole(30),
lv_decimal(30),
lv_delimiter(1),
lv_separator(1),
lv_name(30),
lv_strlen       TYPE i,
lv_ndiv         TYPE i,
lv_nmod         TYPE i,
lv_msgno        TYPE syst_msgno,
ls_return       TYPE bapiret2,
ls_posted       TYPE blntab,
lv_bupla        TYPE bupla,
lv_gsber        TYPE gsber,
lo_exception    TYPE REF TO ycx_ss_exception.
CONSTANTS : lc_dot   TYPE char1 VALUE '.',
lc_comma TYPE char1 VALUE ','.


*Convert Date's to required Format
CONCATENATE : im_document_date+6(2) lc_dot im_document_date+4(2) lc_
im_posting_date+6(2)  lc_dot im_posting_date+4(2)  lc_

*Pass Profit Center to Business Place and Business Area
lv_bupla = im_profit_center.
lv_gsber = im_profit_center.

*Convert Amount to required Format
lv_wrbtr = im_amount.
CONDENSE lv_wrbtr.

SELECT SINGLE dcpfm
INTO lv_dcpfm
FROM usr01
WHERE bname = sy-uname.
IF sy-subrc NE 0.
lv_dcpfm = space. "by default
ENDIF.

*Split Amount
SPLIT lv_wrbtr AT lc_dot INTO lv_whole lv_decimal.
lv_strlen = strlen( lv_whole ).
lv_ndiv   = lv_strlen DIV 3.
lv_nmod   = lv_strlen MOD 3.

*Based on Decimal Format set the amount
CASE lv_dcpfm.
WHEN space.
lv_delimiter = lc_dot .
lv_separator = lc_comma .
TRY.
*Get Payment Amount Notation
CALL METHOD yss_cl_sd_process=>get_amount_notation
EXPORTING
im_delimiter   = lv_delimiter
im_separator   = lv_separator
im_ndiv        = lv_ndiv
im_nmod        = lv_nmod
CHANGING
im_whole_value = lv_wrbtr.
CATCH ycx_ss_exception INTO lo_exception.
lo_exception->log_exception( ).
ENDTRY.

CONCATENATE lv_wrbtr lv_decimal INTO lv_wrbtr SEPARATED BY lv_se

WHEN abap_true.
lv_delimiter = lc_comma.
lv_separator = lc_dot.
TRY.
*Get Payment Amount Notation
CALL METHOD yss_cl_sd_process=>get_amount_notation
EXPORTING
im_delimiter   = lv_delimiter
im_separator   = lv_separator
im_ndiv        = lv_ndiv
im_nmod        = lv_nmod
CHANGING
im_whole_value = lv_wrbtr.
CATCH ycx_ss_exception INTO lo_exception.
lo_exception->log_exception( ).
ENDTRY.
CONCATENATE lv_wrbtr lv_decimal INTO lv_wrbtr SEPARATED BY lv_se
*
WHEN yss_cl_type_pool=>yss_c_y.
lv_delimiter = space.
lv_separator = lc_comma.
TRY.
*get payment amount notation
CALL METHOD yss_cl_sd_process=>get_amount_notation
EXPORTING
im_delimiter   = lv_delimiter
im_separator   = lv_separator
im_ndiv        = lv_ndiv
im_nmod        = lv_nmod
CHANGING
im_whole_value = lv_wrbtr.
CATCH ycx_ss_exception INTO lo_exception.
lo_exception->log_exception( ).
ENDTRY.
CONCATENATE lv_wrbtr lv_decimal INTO lv_wrbtr SEPARATED BY lv_se
WHEN OTHERS.
ENDCASE.
* Header Details

*Document Date
ls_ftpost-stype = yss_cl_type_pool=>yss_c_k.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BKPF-BLDAT'.
ls_ftpost-fval = lv_bldat.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
*Posting Date
ls_ftpost-stype = yss_cl_type_pool=>yss_c_k.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BKPF-BLART'.
ls_ftpost-fval = yss_cl_type_pool=>yss_c_zk.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
*Company Code
ls_ftpost-stype = yss_cl_type_pool=>yss_c_k.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BKPF-BUKRS'.
ls_ftpost-fval = yss_cl_type_pool=>yss_c_rmss.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
*Posting Date
ls_ftpost-stype = yss_cl_type_pool=>yss_c_k.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BKPF-BUDAT'.
ls_ftpost-fval = lv_budat.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
*Currency Key
ls_ftpost-stype = yss_cl_type_pool=>yss_c_k.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BKPF-WAERS'.
ls_ftpost-fval = yss_cl_type_pool=>yss_c_inr.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
*Reference Text
ls_ftpost-stype = yss_cl_type_pool=>yss_c_k.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BKPF-XBLNR'.
ls_ftpost-fval = im_reference.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Item Details

*Posting Key
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'RF05A-NEWBS'.
ls_ftpost-fval = '50'.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Account no.
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'RF05A-NEWKO'.
ls_ftpost-fval = '255020'.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Amount
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BSEG-WRBTR'.
ls_ftpost-fval = lv_wrbtr.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Profit Center
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'COBL-PRCTR'.
ls_ftpost-fval = im_profit_center.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Business Area
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'COBL-GSBER'.
ls_ftpost-fval = lv_gsber.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Business Place
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BSEG-BUPLA'.
ls_ftpost-fval = lv_bupla.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Item Text
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_001.
ls_ftpost-fnam = 'BSEG-SGTXT'.
ls_ftpost-fval = im_text.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Posting Key
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_002.
ls_ftpost-fnam = 'RF05A-NEWBS'.
ls_ftpost-fval = '25'.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Customer Account
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_002.
ls_ftpost-fnam = 'RF05A-NEWKO'.
ls_ftpost-fval = im_customer_account.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.
* Amount
ls_ftpost-stype = yss_cl_type_pool=>yss_c_p.
ls_ftpost-count = yss_cl_type_pool=>yss_c_002.
ls_ftpost-fnam = 'BSEG-WRBTR'.
ls_ftpost-fval = lv_wrbtr.
APPEND ls_ftpost TO lt_ftpost.
CLEAR ls_ftpost.

* Initial information for internal accounting interface
CALL FUNCTION 'POSTING_INTERFACE_START'
EXPORTING
i_function         = yss_cl_type_pool=>yss_c_c
i_group            = 'FB01'
i_user             = sy-uname
EXCEPTIONS
client_incorrect   = 1
function_invalid   = 2
group_name_missing = 3
mode_invalid       = 4
update_invalid     = 5
OTHERS             = 6.
IF sy-subrc <> 0.
MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
ENDIF.

*Post document using the internal posting interface
CALL FUNCTION 'POSTING_INTERFACE_DOCUMENT'
EXPORTING
i_tcode                  = 'FB01'
IMPORTING
e_msgid                  = ex_msgid
e_msgno                  = ex_msgno
e_msgty                  = ex_msgty
e_msgv1                  = ex_msgv1
e_msgv2                  = ex_msgv2
e_msgv3                  = ex_msgv3
e_msgv4                  = ex_msgv4
e_subrc                  = ex_subrc
TABLES
t_blntab                 = ex_posted_documents
t_ftpost                 = lt_ftpost
t_fttax                  = lt_fttax
EXCEPTIONS
account_missing          = 1
company_code_missing     = 2
posting_key_invalid      = 3
posting_key_missing      = 4
record_type_invalid      = 5
transaction_code_invalid = 6
amount_format_error      = 7
too_many_line_items      = 8
company_code_invalid     = 9
screen_not_found         = 10
no_authorization         = 11
OTHERS                   = 12.
IF sy-subrc <> 0.
MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
ENDIF.

*Successful Message
IF ex_posted_documents IS NOT INITIAL.
*Commit Work
COMMIT WORK.
READ TABLE ex_posted_documents INTO ls_posted INDEX 1.
IF sy-subrc = 0.
CONCATENATE 'Document' ls_posted-belnr 'posted in Company Code'
ENDIF.
ENDIF.
*Error Message
IF ex_msgty NE yss_cl_type_pool=>yss_c_s.
CALL FUNCTION 'BALW_BAPIRETURN_GET2'
EXPORTING
type   = ex_msgty
cl     = ex_msgid
number = ex_msgno
IMPORTING
return = ls_return.
ex_msgv3 = ls_return-message.
ENDIF.
*End information for internal accounting interface
CALL FUNCTION 'POSTING_INTERFACE_END'.
IF sy-subrc <> 0.
MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
ENDIF.
ENDMETHOD.
GET_OUTGOING_PAYMENTS_LIST
item
METHOD get_outgoing_payments_list.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Incresol Software Services Pvt. Ltd.
* Created on  : 18-May-2018
* Description : Get Outgoing Payments List
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*

*Types Declarations
TYPES : BEGIN OF lty_bkpf,
bukrs TYPE bkpf-bukrs,
belnr TYPE bkpf-belnr,
gjahr TYPE bkpf-gjahr,
blart TYPE bkpf-blart,
bldat TYPE bkpf-bldat,
budat TYPE bkpf-budat,
stblg TYPE bkpf-stblg,
END OF lty_bkpf.

TYPES : BEGIN OF lty_bseg,
bukrs TYPE bseg-bukrs,
belnr TYPE bseg-belnr,
gjahr TYPE bseg-gjahr,
buzei TYPE bseg-buzei,
gsber TYPE bseg-gsber,
dmbtr TYPE bseg-dmbtr,
lifnr TYPE bseg-lifnr,
prctr TYPE bseg-prctr,
bupla TYPE bseg-bupla,
END OF lty_bseg.

TYPES : BEGIN OF lty_lfa1,
lifnr TYPE lfa1-lifnr,
name1 TYPE lfa1-name1,
name2 TYPE lfa1-name2,
END OF lty_lfa1.

TYPES: BEGIN OF lty_fagl,
ryear  TYPE faglflexa-ryear,
docnr  TYPE faglflexa-docnr,
rldnr  TYPE faglflexa-rldnr,
rbukrs TYPE faglflexa-rbukrs,
docln  TYPE faglflexa-docln,
prctr  TYPE faglflexa-prctr,
END OF lty_fagl.

*Data Declarations
DATA : lt_tvarvc       TYPE rsdsselopt_t,
lwa_tvarvc      TYPE LINE OF rsdsselopt_t,
lt_r_date       TYPE yss_cl_type_pool=>yss_r_date,
lv_from_date    TYPE sy-datum,
lt_bkpf         TYPE TABLE OF lty_bkpf,
ls_bkpf         TYPE lty_bkpf,
lt_bseg         TYPE TABLE OF lty_bseg,
ls_bseg         TYPE lty_bseg,
lt_lfa1         TYPE TABLE OF lty_lfa1,
ls_lfa1         TYPE lty_lfa1,
ls_payment_list TYPE yss_s_out_payments,
lt_fagl         TYPE TABLE OF lty_fagl,
ls_fagl         TYPE lty_fagl.

*Field Symbols declarations
FIELD-SYMBOLS: <lfs_date>  TYPE LINE OF yss_cl_type_pool=>yss_r_date
*To fill lt_r_date
IF im_date IS INITIAL.
*If im_date is initial, Get no. of days from TVARVC table
CALL METHOD yss_cl_util=>get_tvarvc_entries
EXPORTING
im_tvarvc_name = yss_cl_type_pool=>yss_c_incoming_payment_days
IMPORTING
ex_range       = lt_tvarvc.
READ TABLE lt_tvarvc INTO lwa_tvarvc INDEX 1.
IF sy-subrc EQ 0.
lv_from_date = sy-datum - lwa_tvarvc-low.
APPEND INITIAL LINE TO lt_r_date ASSIGNING <lfs_date>.
<lfs_date>-sign = 'I'.
<lfs_date>-option = 'BT'.
<lfs_date>-low = lv_from_date.
<lfs_date>-high = sy-datum.
ENDIF.
ELSE.
APPEND INITIAL LINE TO lt_r_date ASSIGNING <lfs_date>.
<lfs_date>-sign = 'I'.
<lfs_date>-option = 'BT'.
<lfs_date>-low = im_date-low.
<lfs_date>-high = im_date-high.
ENDIF.

*Fetch Accounting Document Header data
SELECT bukrs
belnr
gjahr
blart
bldat
budat
stblg
FROM bkpf
INTO TABLE lt_bkpf
WHERE blart = yss_cl_type_pool=>yss_c_zk
AND   budat IN lt_r_date.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.

SORT lt_bkpf BY belnr.

*General Ledger: Actual Line Items
SELECT ryear
docnr
rldnr
rbukrs
docln
prctr
FROM faglflexa
INTO TABLE lt_fagl
FOR ALL ENTRIES IN lt_bkpf
WHERE ryear  = lt_bkpf-gjahr
AND   docnr  = lt_bkpf-belnr
AND   rbukrs = lt_bkpf-bukrs
AND   prctr  = im_plant_id.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.
SORT lt_fagl BY ryear docnr rbukrs.
*Fetch Accounting Document Segment data
SELECT bukrs
belnr
gjahr
buzei
gsber
dmbtr
lifnr
prctr
bupla
FROM bseg
INTO TABLE lt_bseg
FOR ALL ENTRIES IN lt_fagl
WHERE belnr = lt_fagl-docnr
AND   gjahr = lt_fagl-ryear
AND   bukrs = lt_fagl-rbukrs
AND   koart = yss_cl_type_pool=>yss_c_k.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.
SORT lt_bseg BY bukrs belnr gjahr buzei.

*Fetch Customer Master Name
SELECT lifnr
name1
name2
FROM lfa1
INTO TABLE lt_lfa1
FOR ALL ENTRIES IN lt_bseg
WHERE lifnr = lt_bseg-lifnr.
IF sy-subrc NE 0.
*   Do Nothing
ENDIF.
SORT lt_lfa1 BY lifnr.

*Display List
LOOP AT lt_bseg INTO ls_bseg.
*Company Code
ls_payment_list-company_code = ls_bseg-bukrs.
*Payment ID
ls_payment_list-payment_id   = ls_bseg-belnr.
*Fiscal Year
ls_payment_list-fiscal_year  = ls_bseg-gjahr.
*Customer Account
ls_payment_list-vendor_account = ls_bseg-lifnr.
*Customer Name
READ TABLE lt_lfa1 INTO ls_lfa1 WITH KEY lifnr = ls_bseg-lifnr BIN
IF sy-subrc = 0.
ls_payment_list-vendor_name = ls_lfa1-name1.
ENDIF.
*Date's
READ TABLE lt_bkpf INTO ls_bkpf WITH KEY belnr = ls_bseg-belnr BIN
IF sy-subrc = 0.
*Document Date
ls_payment_list-document_date = ls_bkpf-bldat.
*Posting Date
ls_payment_list-posting_date  = ls_bkpf-budat.
*Reversal/Cancelled Document
ls_payment_list-reversal_doc  = ls_bkpf-stblg.
ENDIF.
*Amount
ls_payment_list-amount = ls_bseg-dmbtr.

APPEND ls_payment_list TO ex_payments_list.
CLEAR : ls_bseg,ls_lfa1,ls_bkpf,ls_payment_list.
ENDLOOP.

ENDMETHOD.
GET_GSTR2
item
METHOD get_gstr2.
TYPES :  BEGIN OF lty_vbrk,
vbeln TYPE vbeln_vf,
fkdat TYPE fkdat,
knumv TYPE knumv,
netwr TYPE netwr,
land1 TYPE lland,
regio TYPE regio,
xblnr TYPE xblnr1,
mwsbk TYPE mwsbp,
bupla TYPE bupla,
END OF lty_vbrk,
BEGIN OF lty_rbkp,
belnr  TYPE re_belnr,
gjahr  TYPE gjahr,
xrech  TYPE xrech,
stblg  TYPE stblg,
rbstat TYPE rbstat,
END OF lty_rbkp,
BEGIN OF lty_konv,
knumv TYPE knumv,
kposn TYPE kposn,
stunr TYPE stunr,
zaehk TYPE dzaehk,
kschl TYPE kscha,
kbetr TYPE kbetr,
kwert TYPE kwert,
END OF lty_konv,
BEGIN OF lty_t005u,
bland TYPE regio,
bezei TYPE bezei20,
END OF lty_t005u,
BEGIN OF lty_lfa1,
lifnr TYPE lifnr,
name1 TYPE name1_gp,
name2 TYPE name1_gp,
stcd3 TYPE stcd3,
END OF lty_lfa1.
TYPES : BEGIN OF lty_vbrp,
vbeln TYPE vbrp-vbeln,
posnr TYPE vbrp-posnr,
netwr TYPE vbrp-netwr,
vgbel	TYPE vgbel,
END OF lty_vbrp.
*++++Start Abhishek 06.06.2018
TYPES : BEGIN OF lty_vbrp_temp,
vbeln TYPE vbrp-vbeln,
posnr TYPE vbrp-posnr,
netwr TYPE vbrp-netwr,
vgbel	TYPE xblnr1,
END OF lty_vbrp_temp,
BEGIN OF lty_ekbe,
ebeln TYPE  ebeln,
ebelp TYPE  ebelp,
zekkn TYPE  dzekkn,
vgabe TYPE  vgabe,
gjahr TYPE  mjahr,
belnr TYPE  mblnr,
buzei TYPE  mblpo,
xblnr TYPE xblnr1,
END OF lty_ekbe.
DATA : lt_vbrp_temp TYPE TABLE OF lty_vbrp_temp,
lt_ekbe      TYPE TABLE OF lty_ekbe,
lt_rbkp      TYPE TABLE OF lty_rbkp.   "++++++Added by Abhish
*++++End Abhishek 06.06.2018
DATA : lt_vbrk  TYPE TABLE OF lty_vbrk,
lt_konv  TYPE TABLE OF lty_konv,
lt_t005u TYPE TABLE OF lty_t005u,
lt_lfa1  TYPE TABLE OF lty_lfa1,
lv_kunrg TYPE kunnr,
lt_t001w TYPE TABLE OF t001w,
lt_vbrp  TYPE TABLE OF lty_vbrp,
ls_vbrp  TYPE lty_vbrp.


SELECT SINGLE kunnr FROM t001w INTO lv_kunrg WHERE werks = im_req_pa
IF sy-subrc EQ 0.

ENDIF.

SELECT vbeln
fkdat
knumv
netwr
land1
regio
xblnr
mwsbk
bupla
FROM vbrk
INTO TABLE lt_vbrk WHERE fkart = 'ZIV'
AND fkdat BETWEEN im_from_date AND im_to_date
AND kunrg = lv_kunrg
AND fksto NE abap_true.
IF sy-subrc EQ 0.
SORT lt_vbrk BY vbeln.

SELECT vbeln
posnr
netwr
vgbel
FROM vbrp
INTO TABLE lt_vbrp
FOR ALL ENTRIES IN lt_vbrk
WHERE vbeln = lt_vbrk-vbeln.
IF sy-subrc = 0.
SORT lt_vbrp BY vbeln posnr.
*<<<<<<<<<<Start Abhishek 06.06.2018
lt_vbrp_temp = lt_vbrp.
SELECT ebeln
ebelp
zekkn
vgabe
gjahr
belnr
buzei
xblnr
FROM ekbe
INTO TABLE lt_ekbe
FOR ALL ENTRIES IN lt_vbrp_temp
WHERE xblnr = lt_vbrp_temp-vgbel
AND bewtp = yss_cl_type_pool=>yss_c_q.
IF sy-subrc EQ 0.
SORT lt_ekbe BY xblnr.
DATA(lt_ekbe_temp) = lt_ekbe.
SORT lt_ekbe_temp BY belnr.
DELETE ADJACENT DUPLICATES FROM lt_ekbe_temp COMPARING belnr.
SELECT belnr
gjahr
xrech
stblg
rbstat
FROM rbkp
INTO TABLE lt_rbkp
FOR ALL ENTRIES IN lt_ekbe_temp
WHERE belnr = lt_ekbe_temp-belnr.
IF sy-subrc EQ 0.
SORT lt_rbkp BY belnr.
ENDIF.
ENDIF.
*>>>>>>>>>>>>End Abhishek
ENDIF.

SELECT *
FROM t001w INTO TABLE lt_t001w
FOR ALL ENTRIES IN lt_vbrk
WHERE werks = lt_vbrk-bupla.
IF sy-subrc EQ 0.
SELECT lifnr
name1
name2
stcd3
FROM lfa1
INTO TABLE lt_lfa1
FOR ALL ENTRIES IN lt_t001w
WHERE lifnr = lt_t001w-lifnr.
IF sy-subrc EQ 0.
ENDIF.
ENDIF.
**Fetch from KONV table
SELECT knumv
kposn
zaehk
stunr
kschl
kbetr
kwert
FROM konv
INTO TABLE lt_konv
FOR ALL ENTRIES IN lt_vbrk
WHERE knumv = lt_vbrk-knumv.
IF sy-subrc EQ 0.
ENDIF.
**Fetch data FROM t005u
SELECT bland
bezei
INTO TABLE lt_t005u
FROM t005u
FOR ALL ENTRIES IN lt_vbrk
WHERE spras EQ yss_cl_type_pool=>yss_c_e AND
bland = lt_vbrk-regio AND
land1 = lt_vbrk-land1.
IF sy-subrc EQ 0.
ENDIF.
ELSE.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>no_gstr2_details_found.
ENDIF.
SORT :  lt_vbrk  BY vbeln,
lt_lfa1  BY lifnr,
lt_konv  BY knumv kposn kschl,
lt_t005u BY bland,
lt_t001w BY werks.

LOOP AT lt_vbrp INTO DATA(lwa_vbrp).
*<<<<<<<<<<start abhishek 06.06.2018  display purchase invoice number
READ TABLE lt_ekbe ASSIGNING FIELD-SYMBOL(<lfs_ekbe>)
WITH KEY xblnr = lwa_vbrp-vgbel BINARY SEARCH.
IF sy-subrc EQ 0.
APPEND INITIAL LINE TO ex_gstr2_list ASSIGNING FIELD-SYMBOL(<lfs
<lfs_gstr2_list>-inv_doc_num = <lfs_ekbe>-belnr.
READ TABLE lt_rbkp ASSIGNING FIELD-SYMBOL(<lfs_rbkp>)
WITH KEY belnr = <lfs_ekbe>-belnr BINARY SEARCH.
IF sy-subrc EQ 0.
IF <lfs_rbkp>-xrech EQ abap_true.
<lfs_gstr2_list>-trans_type = 'Invoice'(013).
ELSE.
<lfs_gstr2_list>-trans_type = 'Credit Memo'(014).
ENDIF.
*For document status

IF <lfs_rbkp>-stblg IS NOT INITIAL.
<lfs_gstr2_list>-doc_status = 'Cancelled'(015).
ENDIF.
ENDIF.
ELSE.
CONTINUE.
ENDIF.
*>>>>>>>>>>>>End Abhishek
READ TABLE lt_vbrk ASSIGNING FIELD-SYMBOL(<lfs_vbrk>) WITH KEY vbe
IF sy-subrc NE 0.
CONTINUE.
ENDIF.
<lfs_gstr2_list>-inv_id = <lfs_vbrk>-vbeln.

READ TABLE lt_t001w ASSIGNING FIELD-SYMBOL(<lfs_t001w>) WITH KEY w
IF sy-subrc EQ 0.
READ TABLE lt_lfa1 ASSIGNING FIELD-SYMBOL(<lfs_lfa1>) WITH KEY l
IF sy-subrc EQ 0.
*SUPPL_NAME
CONCATENATE <lfs_lfa1>-name1 <lfs_lfa1>-name2 INTO <lfs_gstr2_
*GSTIN number
<lfs_gstr2_list>-gstin = <lfs_lfa1>-stcd3.
ENDIF.
ENDIF.
*<<<<<<<<<<<Start Abhishek 07/06/2018
IF <lfs_gstr2_list>-gstin IS NOT INITIAL.
IF <lfs_gstr2_list>-trans_type = 'Invoice'.
<lfs_gstr2_list>-invoice_type = 'B2B'.
ELSE.
<lfs_gstr2_list>-invoice_type = 'CDNR'.
ENDIF.
ELSE.
IF <lfs_gstr2_list>-trans_type = 'Invoice'.
<lfs_gstr2_list>-invoice_type = 'B2BUR'.
ELSE.
<lfs_gstr2_list>-invoice_type = 'CDNUR'.
ENDIF.
ENDIF.
*>>>>>>>>>End Abhishek 07/06/2018
*POS
READ TABLE lt_t005u ASSIGNING FIELD-SYMBOL(<lfs_t005u>) WITH KEY b
IF sy-subrc EQ 0.
<lfs_gstr2_list>-pos = <lfs_t005u>-bezei.
ENDIF.

*invoice date
<lfs_gstr2_list>-inv_date  = <lfs_vbrk>-fkdat.
*Tax val
READ TABLE lt_konv ASSIGNING FIELD-SYMBOL(<lfs_konv>) WITH KEY knu
kpo
ksc
IF sy-subrc EQ 0.
<lfs_gstr2_list>-tax_val   = <lfs_konv>-kwert.
ENDIF.

*IGST
READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = <lfs_vbrk
kposn = lwa_vbrp-
kschl = 'JOIG' BI
IF sy-subrc EQ 0.
<lfs_gstr2_list>-igst = <lfs_konv>-kwert.
<lfs_gstr2_list>-rate = <lfs_konv>-kbetr / 10 .
ENDIF.
*CGST
READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = <lfs_vbrk
kposn = lwa_vbrp-
kschl = 'JOCG' BI
IF sy-subrc EQ 0.
<lfs_gstr2_list>-cgst = <lfs_konv>-kwert.
<lfs_gstr2_list>-rate = <lfs_konv>-kbetr / 10 .
ENDIF.
*SGCT
READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = <lfs_vbrk
kposn = lwa_vbrp-
kschl = 'JOSG' BI
IF sy-subrc EQ 0.
<lfs_gstr2_list>-sgst = <lfs_konv>-kwert.
<lfs_gstr2_list>-rate = <lfs_konv>-kbetr / 10 .
ENDIF.
*Invoice value
<lfs_gstr2_list>-inv_value =    <lfs_gstr2_list>-tax_val + <lfs_gs

ENDLOOP.

***    LOOP AT lt_vbrk ASSIGNING FIELD-SYMBOL(<lfs_vbrk>).
***      APPEND INITIAL LINE TO ex_gstr2_list ASSIGNING FIELD-SYMBOL(<lf
***      <lfs_gstr2_list>-inv_id = <lfs_vbrk>-vbeln.
***      READ TABLE lt_t001w ASSIGNING FIELD-SYMBOL(<lfs_t001w>) WITH KE
***      IF sy-subrc EQ 0.
***        READ TABLE lt_lfa1 ASSIGNING FIELD-SYMBOL(<lfs_lfa1>) WITH KE
***        IF sy-subrc EQ 0.
****SUPPL_NAME
***          CONCATENATE <lfs_lfa1>-name1 <lfs_lfa1>-name2 INTO <lfs_gst
****GSTIN number
***          <lfs_gstr2_list>-gstin = <lfs_lfa1>-stcd3.
***        ENDIF.
***      ENDIF.
****invoice date
***      <lfs_gstr2_list>-inv_date = <lfs_vbrk>-fkdat.
****Invoice value
***      <lfs_gstr2_list>-inv_value =    <lfs_vbrk>-netwr + <lfs_vbrk>-m
****POS
***      READ TABLE lt_t005u ASSIGNING FIELD-SYMBOL(<lfs_t005u>) WITH KE
***      IF sy-subrc EQ 0.
***        <lfs_gstr2_list>-pos = <lfs_t005u>-bezei.
***      ENDIF.
****Rate
***      READ TABLE lt_konv ASSIGNING FIELD-SYMBOL(<lfs_konv>) WITH KEY
***
***      IF sy-subrc EQ 0.
***        <lfs_gstr2_list>-rate = <lfs_konv>-kbetr / 10 .
***      ENDIF.
****Tax val
***      <lfs_gstr2_list>-tax_val =     <lfs_vbrk>-netwr.
****IGST
***      READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = <lfs_v
***                                                       kschl = 'JOIG'
***      IF sy-subrc EQ 0.
***        <lfs_gstr2_list>-igst = <lfs_konv>-kwert.
***        <lfs_gstr2_list>-rate = <lfs_konv>-kbetr / 10 .
***      ENDIF.
****CGST
***      READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = <lfs_v
***                                           kschl = 'JOCG' BINARY SEAR
***      IF sy-subrc EQ 0.
***        <lfs_gstr2_list>-cgst = <lfs_konv>-kwert.
***        <lfs_gstr2_list>-rate = <lfs_konv>-kbetr / 10 .
***      ENDIF.
****SGCT
***      READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = <lfs_v
***                                           kschl = 'JOSG' BINARY SEAR
***      IF sy-subrc EQ 0.
***        <lfs_gstr2_list>-sgst = <lfs_konv>-kwert.
***        <lfs_gstr2_list>-rate = <lfs_konv>-kbetr / 10 .
***      ENDIF.
***    ENDLOOP.
***    DELETE ex_gstr2_list WHERE invoice_type EQ 'CDNR' OR
***                               doc_status EQ 'Cancelled'.
IF ex_gstr2_list IS INITIAL.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>no_gstr2_details_found.
ENDIF.
ENDMETHOD.
FETCH_INTRANSIT_DETAILS
item
METHOD fetch_intransit_details.
*----------------------------------------------------------------------*
*                    A D M I N I S T R A T I O N
*----------------------------------------------------------------------*
* Organization: Incresol Software Services Private Limited             *
* Created by  : Purnachandra Rao V                                     *
* Created on  : 24.05.2018                                             *
* Description : To Fetch Intransit details for Plant (Stock details)   *
*----------------------------------------------------------------------*
*                       C H A N G E    L O G
*----------------------------------------------------------------------*
* <Changed by> | <Changed on> | <Change ID> like USERNAME.DDMMYY
* <Description of change>
*----------------------------------------------------------------------*

* TYPES declaration
TYPES: BEGIN OF lty_ekpo,
ebeln TYPE ebeln,
ebelp TYPE ebelp,
aedat TYPE paedt,
menge TYPE bstmg,
END OF lty_ekpo,
** TYPES for EKBE
BEGIN OF lty_ekbe,
ebeln TYPE ebeln,
belnr TYPE mblnr,
bewtp TYPE bewtp,
bwart TYPE bwart,
budat TYPE budat,
xblnr TYPE char10,
bldat TYPE bldat,
END OF lty_ekbe,
** TYPES for VBFA
BEGIN OF lty_vbfa,
vbelv TYPE vbeln_von,
vbeln TYPE vbeln_nach,
erdat TYPE erdat,
END OF lty_vbfa,
** TYPES for EKKO
BEGIN OF lty_ekko,
ebeln TYPE ebeln,
lifnr TYPE lifnr,
END OF lty_ekko,
** TYPES for LFA1
BEGIN OF lty_lfa1,
lifnr TYPE lifnr,
name1 TYPE name1_gp,
END OF lty_lfa1,
** TYPES for MSEG
BEGIN OF lty_rseg,
belnr TYPE belnr_d,
gjahr TYPE gjahr,
buzei TYPE rblgp,
menge TYPE menge_d,
ebeln TYPE ebeln,
ebelp TYPE ebelp,
END OF lty_rseg,
** TYPES for VBRK
BEGIN OF lty_vbrk,
vbeln TYPE vbeln_vf,
fksto TYPE fksto,
END OF lty_vbrk.
* Local Data declarations
DATA: lt_ekpo  TYPE STANDARD TABLE OF lty_ekpo,
lt_ekpo1 TYPE STANDARD TABLE OF lty_ekpo,
lt_ekbe  TYPE STANDARD TABLE OF lty_ekbe,
lt_vbfa  TYPE STANDARD TABLE OF lty_vbfa,
lt_ekko  TYPE STANDARD TABLE OF lty_ekko,
lt_lfa1  TYPE STANDARD TABLE OF lty_lfa1,
lt_rseg  TYPE STANDARD TABLE OF lty_rseg,
lt_vbrk  TYPE STANDARD TABLE OF lty_vbrk,
lv_year  TYPE mjahr,
lt_ebeln TYPE fip_t_ebeln_range.

* Field Synbol Declaration
FIELD-SYMBOLS: <lfs_ekpo>  TYPE lty_ekpo,
<lfs_ekbe>  TYPE lty_ekbe,
<lfs_vbfa>  TYPE lty_vbfa,
<lfs_ekko>  TYPE lty_ekko,
<lfs_lfa1>  TYPE lty_lfa1,
<lfs_rseg>  TYPE lty_rseg,
<lfs_ebeln> TYPE fip_s_ebeln_range,
<lfs_final> TYPE yss_s_intst_detl.

** Fetch the Purchase order and PO date based on Plant(Input value)
SELECT ebeln
ebelp
aedat
menge
FROM ekpo
INTO TABLE lt_ekpo
WHERE werks EQ im_req_params-werks
AND aedat IN im_date_range AND loekz NE yss_cl_type_pool=>yss_c_
** Fetch the delivery note, date, GRN Number (history category = "E" &
IF lt_ekpo[] IS NOT INITIAL.
SORT lt_ekpo BY ebeln.
DELETE ADJACENT DUPLICATES FROM lt_ekpo COMPARING ebeln.
** Fetch GRN quntity based on PO
SELECT belnr
gjahr
buzei
menge
ebeln
ebelp
FROM rseg
INTO TABLE lt_rseg
FOR ALL ENTRIES IN lt_ekpo
WHERE ebeln EQ lt_ekpo-ebeln
AND ebelp EQ lt_ekpo-ebelp.
IF sy-subrc EQ 0.
SORT lt_rseg BY ebeln ebelp.
ENDIF.
** get the current year value
lv_year = sy-datum+0(4).
SELECT ebeln
belnr
bewtp
bwart
budat
xblnr
bldat
FROM ekbe
INTO TABLE lt_ekbe
FOR ALL ENTRIES IN lt_ekpo
WHERE ebeln EQ lt_ekpo-ebeln.
*          AND gjahr EQ lv_year.
IF lt_ekbe[] IS NOT INITIAL.
SORT lt_ekbe BY ebeln belnr DESCENDING.   "Added by Abhishek
** Fetch LIFNR and name for EBELN
SELECT ebeln
lifnr
FROM ekko
INTO TABLE lt_ekko
FOR ALL ENTRIES IN lt_ekpo
WHERE ebeln EQ lt_ekpo-ebeln.
IF sy-subrc = 0.
SORT lt_ekko.
SELECT lifnr
name1
FROM lfa1
INTO TABLE lt_lfa1
FOR ALL ENTRIES IN lt_ekko
WHERE lifnr EQ lt_ekko-lifnr.
IF sy-subrc = 0.
SORT lt_ekko BY ebeln.
SORT lt_lfa1 BY lifnr.
ENDIF.
ENDIF.
ELSE.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
** Message: No Intransit details avaliable for given plant
textid = ycx_ss_exception=>no_intransit_details_found.
ENDIF.
** Fetch billing doc and date from PO
IF lt_ekbe[] IS NOT INITIAL.
SELECT vbelv
vbeln
erdat
FROM vbfa
INTO TABLE lt_vbfa
FOR ALL ENTRIES IN lt_ekbe
WHERE vbelv EQ lt_ekbe-xblnr
AND vbtyp_n IN (yss_cl_type_pool=>yss_c_5,yss_cl_type_pool=>
IF lt_vbfa[] IS NOT INITIAL.
SORT lt_vbfa BY vbelv.
** For above billing documents, check if cancel or not
** Check the billing doc status from VBRK table
SELECT vbeln
fksto
FROM vbrk
INTO TABLE lt_vbrk
FOR ALL ENTRIES IN lt_vbfa
WHERE vbeln = lt_vbfa-vbeln
AND fksto EQ abap_false.
IF sy-subrc = 0.
SORT lt_vbrk BY vbeln.
ENDIF.
ENDIF.
ENDIF.
ELSE.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
** Message: No Intransit details avaliable for given plant
textid = ycx_ss_exception=>no_intransit_details_found.
ENDIF.

IF lt_ekpo[] IS NOT INITIAL.
** Create final table from above data and send to output
** Loop the EKBE date and move all required field value to final table
LOOP AT lt_ekpo ASSIGNING <lfs_ekpo>.
DATA(lv_menge) = <lfs_ekpo>-menge.
READ TABLE lt_rseg WITH KEY ebeln = <lfs_ekpo>-ebeln ebelp = <lf
IF sy-subrc = 0.
DATA(lv_index) = sy-tabix.
LOOP AT lt_rseg ASSIGNING <lfs_rseg> FROM lv_index.
IF <lfs_rseg>-ebeln NE <lfs_ekpo>-ebeln OR
<lfs_rseg>-ebelp NE <lfs_ekpo>-ebelp.
EXIT.
ENDIF.
lv_menge = lv_menge - <lfs_rseg>-menge.
ENDLOOP.
CLEAR lv_index.
ENDIF.
IF lv_menge IS INITIAL.
CLEAR lv_menge.
CONTINUE.
ENDIF.
**********************************************************************
** Lifnr and Name
READ TABLE lt_ekko ASSIGNING <lfs_ekko> WITH KEY ebeln = <lfs_ek
IF sy-subrc = 0.
APPEND INITIAL LINE TO ex_intst_details ASSIGNING <lfs_final>.
<lfs_final>-lifnr = <lfs_ekko>-lifnr.
READ TABLE lt_lfa1 ASSIGNING <lfs_lfa1> WITH KEY lifnr = <lfs_
IF sy-subrc = 0.
<lfs_final>-name1 = <lfs_lfa1>-name1.
ENDIF.
ELSE.
CONTINUE.
ENDIF.
**********************************************************************
*        APPEND INITIAL LINE TO ex_intst_details ASSIGNING <lfs_final>.
* Read EKBE data and send to output
READ TABLE lt_ekbe ASSIGNING <lfs_ekbe> WITH KEY ebeln = <lfs_ek
IF sy-subrc = 0.
** READ EKBE to get GRN and Purchage Invoice based on history category
IF ( <lfs_ekbe>-bewtp EQ yss_cl_type_pool=>yss_c_e AND <lfs_ek
( <lfs_ekbe>-bewtp EQ yss_cl_type_pool=>yss_c_q ).
<lfs_final>-grn_no = <lfs_ekbe>-belnr.
ENDIF.
IF <lfs_ekbe>-xblnr IS NOT INITIAL.
<lfs_final>-xblnr = <lfs_ekbe>-xblnr.
ELSE.
<lfs_final>-xblnr = <lfs_ekbe>-belnr.
ENDIF.
<lfs_final>-budat  = <lfs_ekbe>-budat.
<lfs_final>-bldat = <lfs_ekbe>-bldat.
** If billing document exist then remove the record from table
** this report is only for Intansit details
READ TABLE lt_vbfa WITH KEY vbelv = <lfs_ekbe>-xblnr BINARY SE
IF sy-subrc EQ 0.
lv_index = sy-tabix.
LOOP AT lt_vbfa ASSIGNING <lfs_vbfa> FROM lv_index .
IF <lfs_vbfa>-vbelv NE <lfs_ekbe>-xblnr.
EXIT.
ENDIF.
READ TABLE lt_vbrk ASSIGNING FIELD-SYMBOL(<lfs_vbrk>) WITH
IF sy-subrc = 0.
<lfs_final>-vbeln_billing = <lfs_vbrk>-vbeln.
<lfs_final>-erdat         = <lfs_vbfa>-erdat.
ENDIF.
ENDLOOP.
ENDIF.

*** Lifnr and Name
*          READ TABLE lt_ekko ASSIGNING <lfs_ekko> WITH KEY ebeln = <lfs
*          IF sy-subrc = 0.
*            <lfs_final>-lifnr = <lfs_ekko>-lifnr.
*            READ TABLE lt_lfa1 ASSIGNING <lfs_lfa1> WITH KEY lifnr = <l
*            IF sy-subrc = 0.
*              <lfs_final>-name1 = <lfs_lfa1>-name1.
*            ENDIF.
*          ENDIF.
ENDIF.
<lfs_final>-ebeln = <lfs_ekpo>-ebeln.
<lfs_final>-aedat = <lfs_ekpo>-aedat.
ENDLOOP.
ELSE.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
** Message: No Intransit details avaliable for given plant
textid = ycx_ss_exception=>no_intransit_details_found.
ENDIF.
IF ex_intst_details[] IS NOT INITIAL.
SORT  ex_intst_details BY ebeln.
DELETE ex_intst_details WHERE ebeln IS INITIAL.
DELETE ex_intst_details WHERE grn_no IS NOT INITIAL.
ENDIF.
** Unassign field symbols
IF <lfs_ekpo> IS ASSIGNED.
UNASSIGN <lfs_ekpo>.
ENDIF.
IF <lfs_ekbe> IS ASSIGNED.
UNASSIGN <lfs_ekbe>.
ENDIF.
IF <lfs_vbfa> IS ASSIGNED.
UNASSIGN <lfs_vbfa>.
ENDIF.
IF <lfs_final> IS ASSIGNED.
UNASSIGN <lfs_final>.
ENDIF.
IF <lfs_ekko> IS ASSIGNED.
UNASSIGN <lfs_final>.
ENDIF.
IF <lfs_lfa1> IS ASSIGNED.
UNASSIGN <lfs_final>.
ENDIF.
IF <lfs_vbrk> IS ASSIGNED.
UNASSIGN <lfs_vbrk>.
ENDIF.
** Clear the internal tables
CLEAR: lt_ekbe,
lt_ekpo,
lt_ekko,
lt_lfa1,
lt_vbfa,
lt_ebeln,
lt_vbrk.

ENDMETHOD.
CANCEL_OUTGOING_PAYMENTS
item
METHOD cancel_outgoing_payments.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Incresol Software Services Pvt. Ltd.
* Created on  : 28-MAY-2018
* Description : Cancel Outgoing Payments
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*

*Types Declarations
TYPES : BEGIN OF lty_bkpf,
bukrs TYPE bkpf-bukrs,
belnr TYPE bkpf-belnr,
gjahr TYPE bkpf-gjahr,
blart TYPE bkpf-blart,
budat TYPE bkpf-budat,
monat TYPE bkpf-monat,
stgrd TYPE bkpf-stgrd,
stblg TYPE bkpf-stblg,
END OF lty_bkpf.
*Data Declarations
DATA : lt_bkpf     TYPE TABLE OF lty_bkpf,
ls_return   TYPE bapiret2,
lv_document TYPE vwpostdoc-sto_docfi,
lv_year     TYPE vwpostdoc-gjahr.

*Field Symbols
FIELD-SYMBOLS : <lfs_documents> TYPE yss_s_payments,
<lfs_bkpf>      TYPE lty_bkpf.

*Fetch Accouning Document Data
SELECT bukrs
belnr
gjahr
blart
budat
monat
stgrd
stblg
FROM bkpf
INTO TABLE lt_bkpf
FOR ALL ENTRIES IN im_documents
WHERE bukrs   = im_documents-bukrs
AND   belnr   = im_documents-belnr
AND   gjahr   = im_documents-gjahr.
IF sy-subrc NE 0.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.

SORT lt_bkpf BY bukrs belnr gjahr.
*Cancel Incoming Payments
LOOP AT im_documents ASSIGNING <lfs_documents>.
READ TABLE lt_bkpf ASSIGNING <lfs_bkpf> WITH KEY bukrs = <lfs_docu
belnr = <lfs_docu
gjahr = <lfs_docu
BINARY SEARCH.
IF sy-subrc = 0 AND <lfs_bkpf>-stblg IS INITIAL.
CALL FUNCTION 'TR_SE_FI_DOCUMENT_REVERSAL'
EXPORTING
i_bukrs              = <lfs_bkpf>-bukrs
i_docnrfi            = <lfs_bkpf>-belnr
i_gjahr              = <lfs_bkpf>-gjahr
i_budat              = <lfs_bkpf>-budat
i_period             = <lfs_bkpf>-monat
i_fi_reversal_reason = '03'
IMPORTING
e_reversal_docnrfi   = lv_document
e_reversal_gjahr     = lv_year
EXCEPTIONS
error_occured        = 1
OTHERS               = 2.
IF lv_document IS NOT INITIAL AND lv_year IS NOT INITIAL.
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait = abap_true.
ls_return-message_v1 = <lfs_documents>-belnr.
ls_return-message_v2 = lv_document.
ls_return-message_v3 = lv_year.
ls_return-message    = 'The Document is Reveresed'.
ls_return-type       = 'S'.
ls_return-number     = '001'.
APPEND ls_return TO ex_return.
ELSE.
ls_return-message_v1 = <lfs_documents>-belnr.
ls_return-message    = 'The Document is not Reveresed'.
ls_return-type       = 'E'.
ls_return-number     = '002'.
APPEND ls_return TO ex_return.
ENDIF.
ELSEIF <lfs_bkpf>-stblg IS NOT INITIAL.
ls_return-message_v1 = <lfs_documents>-belnr.
ls_return-message    = 'The Document is already Reversed'.
ls_return-type       = 'E'.
ls_return-number     = '003'.
APPEND ls_return TO ex_return.
ENDIF.
CLEAR : ls_return,lv_document,lv_year.
ENDLOOP.

ENDMETHOD.
PO_DASHBOARD_DETAILS
item
METHOD po_dashboard_details.
TYPES : BEGIN OF lty_period_value,
inv_date    TYPE spmon,
amount      TYPE rmwwr,
base_amount TYPE rmwwr,
status      TYPE  ddtext,
trans_type  TYPE  char20,
END OF lty_period_value,
BEGIN OF lty_mseg,
mblnr	TYPE mblnr,
mjahr	TYPE mjahr,
zeile	TYPE mblpo,
dmbtr TYPE dmbtr,
END OF lty_mseg.
DATA : lt_mseg         TYPE TABLE OF lty_mseg,
lv_90_days_back TYPE dats,
lv_30_days_back TYPE dats,
lv_1_days_back  TYPE dats,
lt_po_list      TYPE yss_tt_po_list,
lv_period_start TYPE dats,
lv_period_end   TYPE dats,
lv_year_prev    TYPE char4,
lv_year_next    TYPE char4,
lr_date_range   TYPE ranges_budat_tt,
ls_date_range   TYPE range_budat_s,
lt_trans_detail TYPE yss_tt_intst_detl,
lt_goods_list   TYPE yss_tt_goods_receipt,
lt_pur_list     TYPE yss_tt_purchase_inv_list,
lv_amount       TYPE rmwwr,
lt_period_value TYPE TABLE OF lty_period_value,
lv_fisc_mon     TYPE numc2.
*--------------------------pending PO-----------------------------*
lv_30_days_back = sy-datum - 30.
lv_1_days_back = sy-datum - 1.
lv_year_prev = sy-datum+0(4) - 1.
lv_year_next = sy-datum+0(4) + 1.
IF sy-datum+4(2) LE 03.
lv_period_start =  lv_year_prev  && '04' && '01'.
lv_period_end   = sy-datum+0(4) && '03' && '31'.
ELSE.
lv_period_start =  sy-datum+0(4)  && '04' && '01'.
lv_period_end   = lv_year_next && '03' && '31'.
ENDIF.
lv_90_days_back = sy-datum - 90.
IF lv_90_days_back LE lv_period_start.
lv_90_days_back = lv_period_start.
ENDIF.

IF lv_30_days_back LE lv_period_start.
lv_30_days_back = lv_period_start.
ENDIF.

CALL FUNCTION 'YSS_FM_MM_DISPLAY_PO_LIST'
EXPORTING
im_req_params = im_req_params
im_from_date  = lv_90_days_back
im_to_date    = sy-datum
IMPORTING
ex_po_list    = lt_po_list.
DATA(lt_po_list2) = lt_po_list.
LOOP AT lt_po_list ASSIGNING FIELD-SYMBOL(<lfs_list>).
FIND 'Not delivered' IN <lfs_list>-po_deliv_status.
IF sy-subrc NE 0.
DELETE lt_po_list.
ENDIF.
ENDLOOP.
ex_open_po_count = lines( lt_po_list ).

*--------------------------Pending GRN----------------------------*
ls_date_range-sign = yss_cl_type_pool=>yss_c_i.
ls_date_range-option = 'BT'.
ls_date_range-low    = lv_90_days_back.
ls_date_range-high   = sy-datum.
APPEND ls_date_range TO lr_date_range.
CALL FUNCTION 'YSS_FM_MM_INTST_DETAILS'
EXPORTING
im_req_params      = im_req_params
im_date_range      = lr_date_range
IMPORTING
*       EX_RETURN          =
ex_transit_details = lt_trans_detail.
LOOP AT lt_trans_detail ASSIGNING FIELD-SYMBOL(<lfs_trans_detail>).
IF <lfs_trans_detail>-xblnr IS NOT INITIAL AND <lfs_trans_detail>-
ex_open_gr_count = ex_open_gr_count + 1.
ENDIF.
ENDLOOP.

*-------------------------pending PI------------------------------*
CALL FUNCTION 'YSS_FM_MM_GOODS_RECEIPT_LIST'
EXPORTING
im_req_params    = im_req_params
*       IM_PO_NUM        =
*       IM_VENDOR        =
im_from_date     = lv_90_days_back
im_to_date       = sy-datum
IMPORTING
*       EX_RETURN        =
ex_goods_receipt = lt_goods_list.
DATA(lt_goods_list2) = lt_goods_list.

LOOP AT lt_goods_list ASSIGNING FIELD-SYMBOL(<lfs_goods_list>).
IF <lfs_goods_list>-pur_inv_id IS INITIAL AND <lfs_goods_list>-del
ex_open_pi_count = ex_open_pi_count + 1.
ENDIF.
ENDLOOP.
*-------------------------for graph financial year report---------*

CALL FUNCTION 'YSS_FM_MM_GET_PUR_INV_LIST'
EXPORTING
im_req_params        = im_req_params
IMPORTING
*       EX_RETURN            =
ex_purchase_inv_list = lt_pur_list.
DATA(lt_pur_list2) = lt_pur_list.
DELETE lt_pur_list WHERE inv_date NOT BETWEEN lv_period_start AND lv
MOVE-CORRESPONDING lt_pur_list TO lt_period_value.
SORT lt_period_value BY inv_date.
LOOP AT lt_period_value ASSIGNING FIELD-SYMBOL(<lfs_period_val>).
IF <lfs_period_val>-status = 'Generated Invoice' AND <lfs_period_v
lv_amount = lv_amount - <lfs_period_val>-base_amount.
ELSE.
lv_amount = lv_amount + <lfs_period_val>-base_amount.
ENDIF.
AT END OF inv_date.
APPEND INITIAL LINE TO ex_month_sales ASSIGNING FIELD-SYMBOL(<lf
IF <lfs_period_val>-inv_date+4(2) BETWEEN 04 AND 12.
lv_fisc_mon = <lfs_period_val>-inv_date+4(2) - 3 .
ELSE.
CASE <lfs_period_val>-inv_date+4(2).
WHEN '01'.
lv_fisc_mon = '10'.
WHEN '02'.
lv_fisc_mon = '11'.
WHEN '03'.
lv_fisc_mon = '12'.
ENDCASE.
ENDIF.
<lfs_sales>-spbup = <lfs_period_val>-inv_date+0(4) && lv_fisc_mo
<lfs_sales>-sales = lv_amount.
CLEAR lv_amount.
ENDAT.
ENDLOOP.
**********************************************************************
IF sy-datum+4(2) BETWEEN 04 AND 12.
lv_fisc_mon = sy-datum+4(2) - 3 .
ELSE.
CASE sy-datum+4(2).
WHEN '01'.
lv_fisc_mon = '10'.
WHEN '02'.
lv_fisc_mon = '11'.
WHEN '03'.
lv_fisc_mon = '12'.
ENDCASE.
ENDIF.
data : lv_numc TYPE numc2.
DO lv_fisc_mon TIMES.
lv_numc = lv_numc + 1.
APPEND INITIAL LINE TO ex_month_sales ASSIGNING <lfs_sales>.
<lfs_sales>-spbup = sy-datum+0(4) && lv_numc.
<lfs_sales>-sales = 0.
ENDDO.
sort ex_month_sales by spbup sales DESCENDING.
delete ADJACENT DUPLICATES FROM ex_month_sales COMPARING spbup.
**********************************************************************
*--------------------------------PI chart data--------------------------
CLEAR lv_amount.
DELETE lt_po_list2 WHERE po_date NOT BETWEEN lv_30_days_back AND sy-
LOOP AT lt_po_list2 ASSIGNING <lfs_list>.
FIND 'Not delivered' IN <lfs_list>-po_deliv_status.
IF sy-subrc EQ 0.
*        IF <lfs_list>-doc_type ='Returns'.
*          lv_amount = <lfs_list>-base_amount.
*        ENDIF.
ex_open_po_amount = ex_open_po_amount + <lfs_list>-base_amount.
ENDIF.
ENDLOOP.
*    ex_open_po_amount = ex_open_po_amount - lv_amount.
CLEAR lv_amount.
*invoiced amount
DELETE lt_pur_list2 WHERE inv_date NOT BETWEEN lv_30_days_back AND s
LOOP AT lt_pur_list2 ASSIGNING FIELD-SYMBOL(<lfs_pur_list>).
FIND 'Cancel' IN <lfs_pur_list>-status.
IF sy-subrc EQ 0.
lv_amount = lv_amount + <lfs_pur_list>-base_amount.
ENDIF.
IF <lfs_pur_list>-status = 'Generated Invoice' AND <lfs_pur_list>-
lv_amount = lv_amount + <lfs_pur_list>-base_amount.
ENDIF.
ex_invoiced_amount = ex_invoiced_amount + <lfs_pur_list>-base_amou
ENDLOOP.
ex_invoiced_amount = ex_invoiced_amount - lv_amount.
CLEAR lv_amount.
*Uninvoiced amount
DELETE lt_goods_list2 WHERE gr_date NOT BETWEEN lv_30_days_back AND
DELETE lt_goods_list2 WHERE pur_inv_id IS NOT INITIAL.
SORT lt_goods_list2 BY gr_num.
IF lt_goods_list2[] IS NOT INITIAL.
SELECT mblnr
mjahr
zeile
dmbtr FROM mseg
INTO TABLE lt_mseg
FOR ALL ENTRIES IN lt_goods_list2
WHERE mblnr = lt_goods_list2-gr_num.
IF sy-subrc EQ 0.
LOOP AT lt_mseg ASSIGNING FIELD-SYMBOL(<lfs_mseg>).
READ TABLE lt_goods_list2 ASSIGNING FIELD-SYMBOL(<lfs_glst2>)
IF sy-subrc EQ 0.
IF <lfs_glst2>-status EQ 'RETURN'.
lv_amount = lv_amount + <lfs_mseg>-dmbtr.
ENDIF.
ENDIF.
ex_not_invoiced_amount = <lfs_mseg>-dmbtr + ex_not_invoiced_am
ENDLOOP.
ex_not_invoiced_amount = ex_not_invoiced_amount - lv_amount.
ENDIF.
ENDIF.

ENDMETHOD.
FETCH_HOSPITAL_STOCK_DETAILS
item
METHOD fetch_hospital_stock_details.
**Types declarations
TYPES : BEGIN OF lty_vbrk,
vbeln TYPE vbrk-vbeln,
fkart TYPE vbrk-fkart,
fktyp TYPE vbrk-fktyp,
kunag TYPE vbrk-kunag,
fksto TYPE vbrk-fksto,
END OF lty_vbrk,

BEGIN OF lty_vbrp,
vbeln TYPE vbrp-vbeln,
posnr TYPE vbrp-posnr,
fkimg TYPE vbrp-fkimg,
vrkme TYPE vbrp-vrkme,
netwr TYPE vbrp-netwr,
matnr TYPE vbrp-matnr,
werks TYPE vbrp-werks,
END OF lty_vbrp,
BEGIN OF lty_vbrp_tmp,
matnr TYPE vbrp-matnr,
kunnr TYPE vbrk-kunag,
name  TYPE ad_name1,
vbeln TYPE vbrp-vbeln,
posnr TYPE vbrp-posnr,
fkimg TYPE vbrp-fkimg,
vrkme TYPE vbrp-vrkme,
werks TYPE vbrp-werks,
netwr TYPE vbrp-netwr,
END OF lty_vbrp_tmp,
BEGIN OF lty_mseg,
mblnr      TYPE mblnr,
mjahr      TYPE mjahr,
bwart      TYPE bwart,
matnr      TYPE matnr,
dmbtr      TYPE dmbtr,
menge      TYPE menge_d,
ebeln      TYPE bstnr,
ebelp      TYPE ebelp,
xblnr_mkpf TYPE xblnr,
END OF lty_mseg,
BEGIN OF lty_mseg_tmp,
matnr      TYPE matnr,
kunnr      TYPE kunnr,
name       TYPE ad_name1,
mblnr      TYPE mblnr,
mjahr      TYPE mjahr,
bwart      TYPE bwart,
dmbtr      TYPE dmbtr,
menge      TYPE menge_d,
ebeln      TYPE bstnr,
ebelp      TYPE ebelp,
xblnr_mkpf TYPE xblnr,
END OF lty_mseg_tmp,
BEGIN OF lty_vbpa,
vbeln TYPE vbeln,
posnr TYPE posnr,
parvw TYPE parvw,
kunnr	TYPE kunnr,
adrnr	TYPE adrnr,
xcpdk	TYPE xcpdk,
END OF lty_vbpa,
BEGIN OF lty_adrc,
addrnumber TYPE ad_addrnum,
name1      TYPE ad_name1,
END OF lty_adrc,
BEGIN OF lty_po_list,
ebeln TYPE ebeln,
END OF lty_po_list,
BEGIN OF lty_mara,
matnr TYPE matnr,
END OF lty_mara,
BEGIN OF lty_makt,
matnr TYPE matnr,
spras TYPE spras,
maktx TYPE maktx,
END OF lty_makt.
**Data declarations
DATA : lt_vbrk          TYPE STANDARD TABLE OF lty_vbrk,
lt_vbrp          TYPE STANDARD TABLE OF lty_vbrp,
ls_vbrp          TYPE lty_vbrp,
lt_vbrp_tmp      TYPE STANDARD TABLE OF lty_vbrp_tmp,
lt_mseg          TYPE STANDARD TABLE OF lty_mseg,
lt_mseg_tmp      TYPE STANDARD TABLE OF lty_mseg_tmp,
lt_po_list       TYPE STANDARD TABLE OF lty_po_list,
lt_cust_list     TYPE yss_tt_cust_list,
lt_vbpa          TYPE STANDARD TABLE OF lty_vbpa,
lt_adrc          TYPE STANDARD TABLE OF lty_adrc,
lt_mara          TYPE STANDARD TABLE OF lty_mara,
lt_makt          TYPE STANDARD TABLE OF lty_makt,
lt_hospitals     TYPE yss_tt_hospital_stock,
ls_mseg_tmp1     TYPE lty_mseg_tmp,
lr_hospital_code TYPE range_kunnr_tab,
ls_hospital_code TYPE LINE OF range_kunnr_tab,
ls_vbrp_tmp      TYPE lty_vbrp_tmp,
lv_qty           TYPE menge_d,
lv_mat_qty       TYPE menge_d,
lv_price         TYPE netwr,
lv_index         TYPE i,
lo_exception     TYPE REF TO ycx_ss_exception.
**Constants
CONSTANTS: lc_101 TYPE bwart VALUE '101',
lc_102 TYPE bwart VALUE '102',
lc_161 TYPE bwart VALUE '161'.

***    ls_hospital_code-sign   = yss_cl_type_pool=>yss_c_e.
***    ls_hospital_code-option = yss_cl_type_pool=>yss_c_opt_eq.
***    ls_hospital_code-low    = im_hospital_code.
***    APPEND ls_hospital_code TO lr_hospital_code.
***    CLEAR ls_hospital_code.

* Fetch billing details - sales analysis
SELECT vbeln
fkart
fktyp
kunag
fksto
FROM vbrk
INTO TABLE lt_vbrk
WHERE fkdat IN im_date_range
AND   kunag IN im_hospital_code
AND   bupla EQ im_req_params-bupla
AND   fksto EQ abap_false
AND   vbtyp NOT IN ('N','S')
ORDER BY fkdat ASCENDING
%_HINTS ORACLE 'INDEX("VBRK" "VBRK~YSS")'.
IF sy-subrc NE 0.
*      RAISE EXCEPTION TYPE ycx_ss_exception
*        EXPORTING
*          textid = ycx_ss_exception=>not_found.
ENDIF.
IF lt_vbrk IS NOT INITIAL.
* Fetch billing item details
SELECT vbeln
posnr
fkimg
vrkme
netwr
matnr
werks
FROM vbrp
INTO TABLE lt_vbrp
FOR ALL ENTRIES IN lt_vbrk
WHERE vbeln = lt_vbrk-vbeln
AND matnr IN im_material .
IF sy-subrc = 0.
SORT lt_vbrp BY vbeln.
MOVE-CORRESPONDING lt_vbrp TO lt_mara.
MOVE-CORRESPONDING lt_vbrp TO lt_vbrp_tmp.
ENDIF.

* Get the address number based on the Sales and Distribution Document Nu
SELECT vbeln posnr parvw kunnr adrnr xcpdk FROM vbpa INTO TABLE lt
FOR ALL ENTRIES IN lt_vbrk
WHERE vbeln EQ lt_vbrk-vbeln
AND parvw EQ 'WE'.
IF sy-subrc EQ 0.
SORT lt_vbpa BY vbeln.
* Fetch the hospital name
SELECT addrnumber name1
FROM adrc INTO TABLE lt_adrc
FOR ALL ENTRIES IN lt_vbpa
WHERE addrnumber EQ lt_vbpa-adrnr.
IF sy-subrc EQ 0.
SORT lt_adrc BY addrnumber.
ENDIF.
ENDIF.
ENDIF.

* Fetch data from MSEG
SELECT mblnr
mjahr
bwart
matnr
dmbtr
menge
ebeln
ebelp
xblnr_mkpf
FROM mseg
INTO TABLE lt_mseg
WHERE bwart IN (lc_101, lc_102,lc_161)              "101  GR
AND matnr IN im_material
AND werks EQ im_req_params-werks
AND budat_mkpf IN im_date_range.
*           ORDER BY cpudt_mkpf DESCENDING cputm_mkpf DESCENDING
*          %_HINTS ORACLE 'INDEX("MSEG" "MSEG~YSS")'.
IF sy-subrc NE 0.
*      RAISE EXCEPTION TYPE ycx_ss_exception
*        EXPORTING
*          textid = ycx_ss_exception=>goods_rec_no_exist
*          msgv1  = ycx_ss_exception=>format( im_req_params-werks ).
ELSE.
*** SORT  based on MBLNR and delete duplicates to get the latest MIGO nu
SORT lt_mseg BY mblnr DESCENDING.
LOOP AT lt_mseg ASSIGNING FIELD-SYMBOL(<lfs_mseg_temp>).
AT NEW mblnr.
IF <lfs_mseg_temp>-bwart EQ '102'.
LOOP AT lt_mseg ASSIGNING FIELD-SYMBOL(<lfs_mmseg>) WHERE eb
mb
xb
DELETE lt_mseg.
ENDLOOP.
ENDIF.
ENDAT.
ENDLOOP.

DELETE lt_mseg WHERE bwart EQ '102'.
SORT lt_mseg BY mblnr mjahr.
*      DELETE ADJACENT DUPLICATES FROM lt_mseg COMPARING mblnr mjahr.
ENDIF.

*Fetch data from lfa1
LOOP AT lt_mseg INTO DATA(ls_mseg).
APPEND INITIAL LINE TO lt_po_list ASSIGNING FIELD-SYMBOL(<lfs_po_l
<lfs_po_list>-ebeln = ls_mseg-ebeln.

APPEND INITIAL LINE TO lt_mara ASSIGNING FIELD-SYMBOL(<lfs_mara>).
<lfs_mara>-matnr = ls_mseg-matnr.
ENDLOOP.

SORT lt_mara BY matnr.
DELETE ADJACENT DUPLICATES FROM lt_mara COMPARING matnr.

* Fetch material description
IF lt_mara IS NOT INITIAL.
SELECT matnr spras maktx FROM makt
INTO TABLE lt_makt
FOR ALL ENTRIES IN lt_mara
WHERE matnr EQ lt_mara-matnr.
IF sy-subrc EQ 0.
SORT lt_makt BY matnr.
ENDIF.
ENDIF.


***    SORT lt_mseg BY ebeln.
***    DELETE ADJACENT DUPLICATES FROM lt_mseg COMPARING ebeln.
TRY.
CALL METHOD yss_cl_mm_process=>get_kad_code_n_name
EXPORTING
im_po_list   = lt_po_list
IMPORTING
ex_cust_list = lt_cust_list.
CATCH ycx_ss_exception .
ENDTRY.

IF im_hospital_code IS NOT INITIAL.
DELETE lt_cust_list WHERE cust_id NOT IN im_hospital_code.
ENDIF.

MOVE-CORRESPONDING lt_mseg TO lt_mseg_tmp.
SORT: lt_cust_list BY po_num,
lt_mseg_tmp  BY matnr,
lt_vbrp      BY matnr.
*          lt_mseg_tmp  BY ebeln.
SORT:lt_vbrp_tmp BY  vbeln.
LOOP AT lt_vbrk ASSIGNING FIELD-SYMBOL(<lfs_vbrk>).
READ TABLE lt_vbrp_tmp WITH KEY vbeln = <lfs_vbrk>-vbeln TRANSPORT
IF sy-subrc EQ 0.
lv_index = sy-tabix.
LOOP AT lt_vbrp_tmp ASSIGNING FIELD-SYMBOL(<lfs_vbrp_tmp>) FROM
IF <lfs_vbrp_tmp>-vbeln NE <lfs_vbrk>-vbeln.
EXIT.
ELSE.
<lfs_vbrp_tmp>-kunnr = <lfs_vbrk>-kunag.
READ TABLE lt_vbpa INTO DATA(ls_vbpa) WITH KEY vbeln = <lfs_
IF sy-subrc EQ 0.
READ TABLE lt_adrc INTO DATA(ls_adrc) WITH KEY addrnumber
IF sy-subrc EQ 0.
<lfs_vbrp_tmp>-name = ls_adrc-name1.
ENDIF.
ENDIF.
ENDIF.
ENDLOOP.
ENDIF.
ENDLOOP.

CLEAR:lv_index,lv_qty, lv_price.
LOOP AT lt_mseg_tmp ASSIGNING FIELD-SYMBOL(<lfs_mseg_temp1>).

READ TABLE lt_cust_list ASSIGNING FIELD-SYMBOL(<lfs_cust_list>) WI
IF sy-subrc EQ 0.
<lfs_mseg_temp1>-kunnr = <lfs_cust_list>-cust_id.
<lfs_mseg_temp1>-name  = <lfs_cust_list>-cust_name.
ELSE.
CLEAR <lfs_mseg_temp1>-ebeln.
ENDIF.
ENDLOOP.

DELETE lt_mseg_tmp WHERE ebeln IS INITIAL.
SORT lt_mseg_tmp BY matnr kunnr.

LOOP AT lt_mseg_tmp INTO DATA(ls_mseg_tmp).
MOVE-CORRESPONDING ls_mseg_tmp TO ls_mseg_tmp1.
IF ls_mseg_tmp1-bwart EQ 161.
lv_qty = lv_qty - ls_mseg_tmp1-menge.
lv_price = lv_price - ls_mseg_tmp1-dmbtr.
ELSE.
lv_qty = lv_qty + ls_mseg_tmp1-menge.
lv_price = lv_price + ls_mseg_tmp1-dmbtr.
ENDIF.
AT END OF kunnr.
APPEND INITIAL LINE TO lt_hospitals ASSIGNING FIELD-SYMBOL(<lfs_
<lfs_hospitals>-purchase_qty   = lv_qty.
<lfs_hospitals>-purchase_price = lv_price.
<lfs_hospitals>-hospital_code  = ls_mseg_tmp1-kunnr.
<lfs_hospitals>-hospital_name  = ls_mseg_tmp1-name.
lv_mat_qty = lv_mat_qty + lv_qty.
CLEAR : lv_qty, lv_price.
ENDAT.
AT END OF matnr.
APPEND INITIAL LINE TO ex_stock_details ASSIGNING FIELD-SYMBOL(<
lv_index = lv_index + 1.
<lfs_stock_details>-seq_num      = lv_index.
<lfs_stock_details>-material     = ls_mseg_tmp1-matnr.
<lfs_stock_details>-hospitals    = lt_hospitals.
<lfs_stock_details>-purchase_qty = lv_mat_qty.
CLEAR :lv_qty,lt_hospitals,lv_price,lv_mat_qty.

READ TABLE lt_makt INTO DATA(ls_makt) WITH KEY matnr = ls_mseg_t
IF sy-subrc EQ 0.
<lfs_stock_details>-mat_desc = ls_makt-maktx.
ENDIF.
ENDAT.
CLEAR:ls_mseg_tmp1.
ENDLOOP.

SORT :lt_vbrp_tmp BY matnr kunnr,
lt_vbrk BY vbeln.
CLEAR:lv_qty, lv_price,lv_mat_qty.
LOOP AT lt_vbrp_tmp INTO DATA(ls_vbrp_tmp1).

MOVE-CORRESPONDING ls_vbrp_tmp1 TO ls_vbrp_tmp."ls_vbrp.
READ TABLE lt_vbrk ASSIGNING <lfs_vbrk> WITH KEY vbeln = ls_vbrp_t
IF sy-subrc EQ 0 .
IF <lfs_vbrk>-fkart = 'ZRKS'.
lv_qty   = lv_qty   - ls_vbrp_tmp-fkimg.
lv_price = lv_price - ls_vbrp_tmp-netwr.
ELSE.
lv_qty   = lv_qty + ls_vbrp_tmp-fkimg.
lv_price = lv_price + ls_vbrp_tmp-netwr.
ENDIF.
ENDIF.
*      lv_qty   = lv_qty + ls_vbrp_tmp-fkimg.
*      lv_price = lv_price + ls_vbrp_tmp-netwr.
AT END OF kunnr.
READ TABLE ex_stock_details ASSIGNING <lfs_stock_details> WITH K
IF sy-subrc EQ 0.
READ TABLE <lfs_stock_details>-hospitals ASSIGNING <lfs_hospit
IF sy-subrc EQ 0.
<lfs_hospitals>-supplied_qty   = lv_qty.
<lfs_hospitals>-supplied_price = lv_price.
<lfs_hospitals>-balance_qty    = <lfs_hospitals>-purchase_qt
lv_mat_qty = lv_mat_qty + lv_qty.
CLEAR: lv_qty,lv_price.
ELSE.
APPEND INITIAL LINE TO <lfs_stock_details>-hospitals ASSIGNI
<lfs_hospitals>-supplied_qty   = lv_qty.
<lfs_hospitals>-supplied_price = lv_price.
<lfs_hospitals>-hospital_code  = ls_vbrp_tmp-kunnr.
<lfs_hospitals>-hospital_name  = ls_vbrp_tmp-name.
<lfs_hospitals>-balance_qty    = <lfs_hospitals>-purchase_qt
lv_mat_qty = lv_mat_qty + lv_qty.
CLEAR :lv_qty,lv_price.
ENDIF.
ELSE.
REFRESH:lt_hospitals.
APPEND INITIAL LINE TO lt_hospitals ASSIGNING <lfs_hospitals>.
<lfs_hospitals>-supplied_qty   = lv_qty.
<lfs_hospitals>-supplied_price = lv_price.
<lfs_hospitals>-hospital_code  = ls_vbrp_tmp-kunnr.
<lfs_hospitals>-hospital_name  = ls_vbrp_tmp-name.
<lfs_hospitals>-balance_qty    = <lfs_hospitals>-purchase_qty
lv_mat_qty = lv_mat_qty + lv_qty.
CLEAR :lv_qty,lv_price.
APPEND INITIAL LINE TO ex_stock_details ASSIGNING <lfs_stock_d
lv_index = lv_index + 1.
<lfs_stock_details>-seq_num      = lv_index.
<lfs_stock_details>-material     = ls_vbrp_tmp-matnr.
<lfs_stock_details>-hospitals    = lt_hospitals.
CLEAR :lv_qty,lt_hospitals,lv_price.

READ TABLE lt_makt INTO ls_makt WITH KEY matnr = ls_vbrp_tmp-m
IF sy-subrc EQ 0.
<lfs_stock_details>-mat_desc = ls_makt-maktx.
ENDIF.
ENDIF.
ENDAT.
AT END OF matnr.
READ TABLE ex_stock_details ASSIGNING <lfs_stock_details> WITH K
IF sy-subrc = 0.
<lfs_stock_details>-supplied_qty = lv_mat_qty.
<lfs_stock_details>-balance_qty  = <lfs_stock_details>-purchas
ENDIF.
CLEAR:lv_mat_qty.
ENDAT.
ENDLOOP.
IF ex_stock_details IS INITIAL.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>not_found.
ENDIF.
ENDMETHOD.
CREATE_INCOMING_INVOICE_2
item
METHOD create_incoming_invoice_2.
*TYPES declarations
TYPES : BEGIN OF lty_ekpo,
ebeln TYPE ekpo-ebeln,
ebelp TYPE ekpo-ebelp,
ktmng TYPE ekpo-ktmng,
menge TYPE ekpo-menge,
meins TYPE ekpo-meins,
netwr TYPE ekpo-netwr,
mwskz TYPE ekpo-mwskz,
END OF lty_ekpo,

BEGIN OF lty_mkpf,
mblnr TYPE mkpf-mblnr,
mjahr TYPE mkpf-mjahr,
bldat TYPE mkpf-bldat,
xblnr TYPE mkpf-xblnr,
END OF lty_mkpf,
BEGIN OF lty_rbkp,
belnr  TYPE re_belnr,
gjahr  TYPE gjahr,
bldat  TYPE bldat,
vgart  TYPE vgart,
lifnr  TYPE lifre,
rmwwr  TYPE rmwwr,
stblg  TYPE stblg,
rbstat TYPE rbstat,
END OF lty_rbkp,

BEGIN OF lty_rseg,
belnr	TYPE belnr_d,
gjahr	TYPE gjahr,
buzei	TYPE rblgp,
ebeln TYPE ebeln,
wrbtr TYPE wrbtr,
xblnr	TYPE xblnr1,
END OF lty_rseg,
BEGIN OF lty_mseg,
mblnr   TYPE mseg-mblnr,
mjahr   TYPE mseg-mjahr,
zeile   TYPE mseg-zeile,
line_id TYPE mseg-line_id,
bwart   TYPE bwart,
matnr   TYPE mseg-matnr,
dmbtr   TYPE mseg-dmbtr,
menge   TYPE mseg-menge,
meins   TYPE mseg-meins,
ebeln   TYPE mseg-ebeln,
ebelp   TYPE mseg-ebelp,
lfbnr   TYPE mseg-lfbnr,
smbln   TYPE mseg-smbln,
END OF lty_mseg.

DATA : ls_header           TYPE bapi_incinv_create_header,
lt_item             TYPE STANDARD TABLE OF bapi_incinv_create
lt_mseg             TYPE STANDARD TABLE OF lty_mseg,
lt_rseg             TYPE STANDARD TABLE OF lty_rseg,
lt_rbkp             TYPE STANDARD TABLE OF lty_rbkp,
lt_ekpo             TYPE STANDARD TABLE OF lty_ekpo,
ls_rbkp             TYPE lty_rbkp,
lt_konv             TYPE TABLE OF konv,
ls_item             TYPE bapi_incinv_create_item,
lv_fyear            TYPE bapi_incinv_fld-fisc_year,
lv_invno            TYPE bapi_incinv_fld-inv_doc_no,
ls_req_params       TYPE yss_s_req_params,
lt_mat_desc         TYPE yss_tt_mat,
lv_price_difference TYPE konv-kwert,
ls_return           TYPE bapiret2,
ls_ekko             TYPE ekko,
ls_mkpf             TYPE mkpf,
lv_lifnr            TYPE lifnr,
lt_accit            TYPE accit_t,
lt_accr             TYPE acccr_t,
ls_accit            TYPE accit.
CONSTANTS : lc_101 TYPE char3 VALUE '101',
lc_102 TYPE char3 VALUE '102'.
*--------------------Check for duplicate invoice ------++Abhishek
IF im_action = yss_cl_type_pool=>yss_c_ci or im_action = yss_cl_type
SELECT belnr
gjahr
buzei
ebeln
wrbtr
xblnr
INTO TABLE lt_rseg FROM rseg WHERE ebeln = im_ebeln.
IF sy-subrc EQ 0.
SORT lt_rseg BY belnr DESCENDING.
READ TABLE lt_rseg ASSIGNING FIELD-SYMBOL(<lfs_rseg>) INDEX 1.
IF sy-subrc EQ 0.
SELECT SINGLE belnr
gjahr
bldat
vgart
lifnr
rmwwr
stblg
rbstat
FROM rbkp
INTO ls_rbkp
WHERE belnr = <lfs_rseg>-belnr.
IF ls_rbkp-vgart EQ 'RD' AND ls_rbkp-stblg IS INITIAL.
RAISE EXCEPTION TYPE ycx_ss_exception
EXPORTING
textid = ycx_ss_exception=>invoice_exists_for_po
msgv1  = ycx_ss_exception=>format( im_ebeln ).
ENDIF.
ENDIF.
ENDIF.
ENDIF.
*--------------------------------------------------------------------*

*Fetch purchase order header data
SELECT SINGLE * FROM ekko INTO ls_ekko  WHERE ebeln = im_ebeln.
IF sy-subrc EQ 0.
*Fetch from Condition table
SELECT * FROM konv INTO TABLE lt_konv WHERE knumv = ls_ekko-knumv.
IF sy-subrc EQ 0.
ENDIF.
ENDIF.

*Fetch purchase order item data
SELECT ebeln ebelp ktmng menge meins netwr mwskz FROM ekpo
INTO TABLE lt_ekpo
WHERE ebeln = im_ebeln AND
loekz NE yss_cl_type_pool=>yss_c_l ORDER BY PRIMARY KEY.
IF sy-subrc EQ 0.
"Do nothing
ENDIF.

*Fetch goods receipt item data
SELECT mblnr
mjahr
zeile
line_id
bwart
matnr
dmbtr
menge
meins
ebeln
ebelp
lfbnr
smbln
FROM mseg
INTO TABLE lt_mseg
WHERE ebeln = im_ebeln.
IF sy-subrc EQ 0.
SORT lt_mseg BY mblnr DESCENDING.
READ TABLE lt_mseg ASSIGNING FIELD-SYMBOL(<lfs_mseg_header>) INDEX
IF sy-subrc EQ 0.
IF <lfs_mseg_header>-bwart EQ lc_101.
DELETE lt_mseg WHERE lfbnr LT <lfs_mseg_header>-lfbnr.
ELSEIF <lfs_mseg_header>-bwart EQ lc_102.
ls_return-message    = 'GRN is pending for order &'.
REPLACE '&' IN ls_return-message WITH im_ebeln.
ls_return-type       = yss_cl_type_pool=>yss_c_e.
APPEND ls_return TO ex_return.
CLEAR ls_return.
RETURN.
ENDIF.
*Fetch goods receipt header data
SELECT SINGLE *
FROM mkpf
INTO ls_mkpf
WHERE mblnr = <lfs_mseg_header>-mblnr.
IF sy-subrc EQ 0.
ENDIF.
ENDIF.
*Fetch material text
SELECT matnr
maktx FROM makt
INTO TABLE lt_mat_desc
FOR ALL ENTRIES IN lt_mseg
WHERE matnr = lt_mseg-matnr.
IF sy-subrc EQ 0.
ENDIF.
ENDIF.
*prepare header
ls_header-invoice_ind = abap_true.
ls_header-doc_date    = im_document_date.
ls_header-pstng_date  = im_posting_date.
ls_header-ref_doc_no  = im_ebeln.
ls_header-header_txt  = im_header_text.
ls_header-comp_code   = yss_cl_type_pool=>yss_c_rmss.
ls_header-currency    = yss_cl_type_pool=>yss_c_inr.
LOOP AT lt_konv ASSIGNING FIELD-SYMBOL(<lfs_konv>) WHERE kschl = 'NA
ls_header-gross_amount = ls_header-gross_amount + <lfs_konv>-kawrt
ENDLOOP.
ls_header-calc_tax_ind = abap_true.
ls_header-pmnttrms     = yss_cl_type_pool=>yss_c_0001.
ls_header-bline_date   = im_baseline_date.
ls_header-bus_area     = im_werks.
ls_header-diff_inv     = im_inv_party.

*prepare item
LOOP AT lt_mseg ASSIGNING FIELD-SYMBOL(<lfs_mseg>).
APPEND INITIAL LINE TO lt_item ASSIGNING FIELD-SYMBOL(<lfs_item>).
<lfs_item>-invoice_doc_item = <lfs_mseg>-zeile.
<lfs_item>-po_number        = im_ebeln.
READ TABLE lt_ekpo ASSIGNING FIELD-SYMBOL(<lfs_ekpo>)
WITH KEY ebeln = im_ebeln
ebelp = <lfs_mseg>-ebelp BINARY SEARCH.
IF sy-subrc EQ 0.
<lfs_item>-po_item  = <lfs_ekpo>-ebelp.
<lfs_item>-tax_code = <lfs_ekpo>-mwskz.
ENDIF.
<lfs_item>-ref_doc      = <lfs_mseg>-mblnr.
<lfs_item>-quantity     = <lfs_mseg>-menge.
<lfs_item>-ref_doc_it   = <lfs_mseg>-zeile.
<lfs_item>-item_amount  = <lfs_mseg>-dmbtr.
<lfs_item>-ref_doc_year = <lfs_mseg>-mjahr.
<lfs_item>-po_unit_iso  = <lfs_mseg>-meins.
**Get Simulated Data
APPEND INITIAL LINE TO ex_calculated_data ASSIGNING FIELD-SYMBOL(<
<lfs_calc_data>-po_no         = im_ebeln.
<lfs_calc_data>-po_item_no    = <lfs_mseg>-ebelp.
<lfs_calc_data>-gr_no         = <lfs_mseg>-mblnr.
<lfs_calc_data>-gr_item_no    = <lfs_mseg>-zeile.
<lfs_calc_data>-gr_date       = ls_mkpf-bldat.
<lfs_calc_data>-material_code = <lfs_mseg>-matnr.
READ TABLE lt_mat_desc ASSIGNING FIELD-SYMBOL(<lfs_mat_desc>) WITH
IF sy-subrc EQ 0.
<lfs_calc_data>-material_name = <lfs_mat_desc>-mat_name.
ENDIF.
<lfs_calc_data>-quantity    = <lfs_mseg>-menge.
<lfs_calc_data>-uom         = <lfs_mseg>-meins.
<lfs_calc_data>-value       = <lfs_mseg>-dmbtr.
<lfs_calc_data>-base_value = <lfs_mseg>-dmbtr / <lfs_mseg>-menge.
READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = ls_ekko-k
kposn = <lfs_mseg
kschl = yss_cl_ty
krech = yss_cl_ty
IF sy-subrc EQ 0.
<lfs_calc_data>-cgst_rate = ( <lfs_konv>-kbetr / 10 ).
<lfs_calc_data>-cgst_amt  = ( <lfs_mseg>-dmbtr * ( <lfs_konv>-kb
<lfs_calc_data>-discount_value = <lfs_calc_data>-discount_value
ENDIF.
READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = ls_ekko-k
kposn = <lfs_mseg
kschl = yss_cl_ty
krech = yss_cl_ty
IF sy-subrc EQ 0.
<lfs_calc_data>-sgst_rate =   <lfs_konv>-kbetr / 10 .
<lfs_calc_data>-sgst_amt  = ( <lfs_mseg>-dmbtr * ( <lfs_konv>-kb
<lfs_calc_data>-discount_value = <lfs_calc_data>-discount_value
ENDIF.
READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = ls_ekko-k
kposn = <lfs_mseg
kschl = yss_cl_ty
krech = yss_cl_ty
IF sy-subrc EQ 0.
<lfs_calc_data>-igst_rate = <lfs_konv>-kbetr / 10 .
<lfs_calc_data>-igst_amt  = ( <lfs_mseg>-dmbtr * ( <lfs_konv>-kb
<lfs_calc_data>-discount_value = <lfs_calc_data>-discount_value
ENDIF.
READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = ls_ekko-k
kposn = <lfs_mseg
kschl = 'NAVS'.
IF sy-subrc EQ 0.
<lfs_calc_data>-net_amount = <lfs_konv>-kawrt .
ENDIF.

READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = ls_ekko-k
kposn = <lfs_mseg>-ebel
kschl = 'PBXX'.
IF sy-subrc EQ 0.
<lfs_calc_data>-unit_price = <lfs_konv>-kbetr .
ENDIF.

READ TABLE lt_konv ASSIGNING <lfs_konv> WITH KEY knumv = ls_ekko-k
kposn = <lfs_mseg>-ebelp
kschl = 'PB00'.
IF sy-subrc EQ 0.
<lfs_calc_data>-unit_price = <lfs_konv>-kbetr .
ENDIF.


IF <lfs_ekpo> IS ASSIGNED.
<lfs_calc_data>-tax_code = <lfs_ekpo>-mwskz.
ENDIF.
ENDLOOP.

**Based on action given processing happens
CASE im_action.
WHEN yss_cl_type_pool=>yss_c_si.
*Simulate
ex_header = ls_header.
ex_item   = lt_item.
CALL FUNCTION 'MRM_SRM_INVOICE_SIMULATE'
EXPORTING
headerdata = ex_header
IMPORTING
return     = ex_return
t_accit    = lt_accit
t_acccr    = lt_accr
TABLES
itemdata   = ex_item.
IF lt_accit IS NOT INITIAL.
SORT lt_accit BY ktosl.
DELETE lt_accit WHERE ktosl NE 'EIN'.
LOOP AT lt_accit INTO ls_accit.
lv_price_difference = lv_price_difference + ls_accit-pswbt.
CLEAR : ls_accit.
ENDLOOP.
*Price difference amount
ex_price_difference = lv_price_difference.
ENDIF.
*To fetch the vendor details
ls_req_params-werks = im_werks.
lv_lifnr = ls_ekko-lifnr.
IF lv_lifnr IS NOT INITIAL.
CALL METHOD yss_cl_mm_process=>fetch_vendor_details
EXPORTING
im_req_params     = ls_req_params
im_vendor         = lv_lifnr
IMPORTING
ex_vendor_details = ex_vendor_details.
ENDIF.

*Create
WHEN yss_cl_type_pool=>yss_c_ci.
*Bapi to Create Purchase Invoice
CALL FUNCTION 'BAPI_INCOMINGINVOICE_CREATE'
EXPORTING
headerdata       = ls_header
IMPORTING
invoicedocnumber = lv_invno
fiscalyear       = lv_fyear
TABLES
itemdata         = lt_item
return           = ex_return.
IF lv_invno IS NOT INITIAL AND
lv_fyear IS NOT INITIAL.
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait = abap_true.
ls_return-message_v1 = lv_invno.
ls_return-message_v2 = lv_fyear.
ls_return-message    = 'The Invoice & is Created'.
REPLACE '&' IN ls_return-message WITH lv_invno.
ls_return-type       = yss_cl_type_pool=>yss_c_i.
ls_return-number     = yss_cl_type_pool=>yss_c_001.
APPEND ls_return TO ex_return.
CLEAR ls_return.
ENDIF.
ENDCASE.

ENDMETHOD.
CREATE_CREDIT_MEMO
item
METHOD create_credit_memo.
***********************************************************************
* Administration:                                                     *
*---------------------------------------------------------------------*
* Created by  : Incresol Software Services Pvt. Ltd.
* Created on  : 29-JAN-2019
* Description : Create Credit Memo w.r.t Outbound Delivery
***********************************************************************
* Change History:                                                     *
* --------------------------------------------------------------------*
* Date       | Change ID     |  Short Description                     *
* --------------------------------------------------------------------*
* DD-MM-YYYY | USERID.DDMMYY |                                        *
* --------------------------------------------------------------------*

*TYPES declarations
TYPES:
BEGIN OF lty_vbrp,
vbeln        TYPE vbeln_vf,
posnr        TYPE posnr_vf,
fkimg        TYPE fkimg,
netwr        TYPE netwr_fp, "22
aubel	       TYPE vbeln_va,
aupos	       TYPE posnr_va,
cmpre        TYPE cmpre, "106
mwsbp	       TYPE mwsbp, "135
lv_unitprice TYPE netwr_fp,
END OF   lty_vbrp,

BEGIN OF lty_vbfa,
posnv	TYPE posnr_von,
vbeln	TYPE vbeln_nach,
posnn	TYPE posnr_nach,
END OF lty_vbfa.

*Data Declaration
DATA:
lv_vbeln        TYPE likp-vbeln,
lv_invno        TYPE bapi_incinv_fld-inv_doc_no,
lv_fyear        TYPE bapi_incinv_fld-fisc_year,
lt_vbrp         TYPE STANDARD TABLE OF lty_vbrp,
lt_item         TYPE STANDARD TABLE OF bapi_incinv_create_item,
ls_header       TYPE bapi_incinv_create_header,
lv_gross_amount TYPE netwr,
lv_tax_amount   TYPE netwr,
ls_billing      TYPE lty_vbfa,
ls_goodsinv     TYPE lty_vbfa,
lv_fkdat        TYPE fkdat,
lt_item_details TYPE yss_tt_lips,
ls_return       TYPE bapiret2,
lt_ekpo         TYPE TABLE OF ekpo,
lv_count        TYPE i,
lv_amount       TYPE p LENGTH 12 DECIMALS 2.
CONSTANTS:
lc_intcompinv TYPE char1 VALUE '5',
lc_inv        TYPE char1 VALUE 'J',
lc_doctyp     TYPE char1 VALUE 'I',
lc_goodsinv   TYPE char1 VALUE 'i'.

*Add Leading Zero's
CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
EXPORTING
input  = im_vbeln
IMPORTING
output = lv_vbeln.

CLEAR:
ls_billing,
lv_fkdat,
ls_header,
lv_gross_amount,
lt_vbrp[],
*      ls_item,
lt_item[].

* move the internal table data to temporary
lt_item_details = im_item_details.
DATA : ls_ekko TYPE ekko,
lt_konv TYPE TABLE OF konv.
IF lt_item_details IS NOT INITIAL.
SELECT * FROM ekpo
INTO TABLE lt_ekpo
FOR ALL ENTRIES IN lt_item_details
WHERE ebeln = lt_item_details-vgbel.
IF sy-subrc EQ 0.
READ TABLE lt_ekpo ASSIGNING FIELD-SYMBOL(<lfs_ekpo>) INDEX 1.
SELECT SINGLE knumv FROM ekko INTO ls_ekko-knumv WHERE ebeln  =
IF sy-subrc EQ 0.
SELECT * FROM konv
INTO TABLE lt_konv
*            FOR ALL ENTRIES IN lt_ekpo
WHERE knumv = ls_ekko-knumv.
*            AND   mwsk1 = lt_ekpo-mwskz.
IF sy-subrc EQ 0.
DELETE lt_konv WHERE kschl <> 'JIIG' AND
kschl <> 'JICG' AND
kschl <> 'JISG'.
ENDIF.
ENDIF.
ENDIF.
ENDIF.

**Fetch billing details
SELECT
posnv                           "Preceding item of an SD docum
vbeln                           "Subsequent sales and distribu
posnn                           "Subsequent item of an SD docu
FROM vbfa
INTO ls_billing
WHERE vbelv   = lv_vbeln            "Delivery
AND vbtyp_n = lc_intcompinv       "Intercompany invoice
AND vbtyp_v = lc_inv              "Invoice
AND fktyp   = lc_doctyp.          "Delivery
ENDSELECT.
IF sy-subrc EQ 0.
"Do nothing
ENDIF.


**Fetch goods receipt
SELECT posnv                           "Preceding item of an SD docu
vbeln                           "Subsequent sales and distrib
posnn                           "Subsequent item of an SD doc
FROM vbfa
INTO ls_goodsinv
WHERE vbelv EQ lv_vbeln               "DELIVERY
AND vbtyp_n  EQ lc_goodsinv.        "i
ENDSELECT.

IF ls_billing-vbeln IS NOT INITIAL.
**Fetch billing item details from VBRP
SELECT vbeln
posnr
fkimg
netwr
aubel
aupos
cmpre
mwsbp
FROM vbrp
INTO TABLE lt_vbrp
WHERE vbeln = ls_billing-vbeln AND
vgbel = lv_vbeln. "Billing
IF sy-subrc EQ 0.
* Do nothing
ENDIF.
ENDIF.

**Header Data
ls_header-ref_doc_no     = ls_billing-vbeln.
ls_header-invoice_ind    = abap_false.                   " Enter Inv
ls_header-doc_date       = sy-datum.                     " Enter the
ls_header-pstng_date     = sy-datum.                     " Enter the
ls_header-bline_date     = sy-datum.                     " Baseline
ls_header-comp_code      = yss_cl_type_pool=>yss_c_rmss. " Enter Com
ls_header-calc_tax_ind   = abap_true.                    " Enter Cal
ls_header-currency       = yss_cl_type_pool=>yss_c_inr.  " Enter Cur
ls_header-bus_area       = im_werks.                     " Enter Bus
ls_header-business_place = im_werks.                     " Business
ls_header-pmnttrms       = yss_cl_type_pool=>yss_c_0001. " Enter pay

LOOP AT lt_vbrp ASSIGNING FIELD-SYMBOL(<fs_vbrp>).
* calculate unit price
IF <fs_vbrp>-fkimg IS NOT INITIAL.
<fs_vbrp>-lv_unitprice = ( <fs_vbrp>-netwr / <fs_vbrp>-fkimg ).
ENDIF.
ENDLOOP.

CLEAR lv_count.

LOOP AT lt_item_details ASSIGNING FIELD-SYMBOL(<lfs_item_details>).
APPEND INITIAL LINE TO lt_item ASSIGNING FIELD-SYMBOL(<lfs_item>).
lv_count                 = lv_count + 1.
<lfs_item>-invoice_doc_item = lv_count.
<lfs_item>-po_number        = <lfs_item_details>-vgbel. "505000057
<lfs_item>-po_item          = <lfs_item_details>-vgpos.
<lfs_item>-ref_doc_year = <lfs_item_details>-erdat+0(4).
<lfs_item>-ref_doc_it   = lv_count.
<lfs_item>-quantity     = <lfs_item_details>-lfimg.
<lfs_item>-po_unit      = <lfs_item_details>-meins.
<lfs_item>-po_unit_iso  = <lfs_item_details>-meins.
IF ls_goodsinv-vbeln IS NOT INITIAL.
<lfs_item>-ref_doc    = ls_goodsinv-vbeln.
ENDIF.
*item amount
READ TABLE lt_vbrp
INTO DATA(lwa_vbrp)
WITH KEY aubel = <lfs_item_details>-vgbel
aupos = <lfs_item_details>-vgpos.
IF sy-subrc EQ 0 AND <lfs_item_details>-lfimg IS NOT INITIAL.
<lfs_item>-item_amount = ( <lfs_item_details>-lfimg * lwa_vbrp-l
ENDIF.
***gross amount

READ TABLE lt_ekpo ASSIGNING <lfs_ekpo>
WITH KEY ebeln = <lfs_item_details>-v
ebelp = <lfs_item_details>-v
IF sy-subrc EQ 0.
LOOP AT lt_konv ASSIGNING FIELD-SYMBOL(<lfs_konv>) WHERE  knumv
AND  kposn
lv_tax_amount = lv_tax_amount + ( <lfs_item>-item_amount * ( <
lv_amount =  <lfs_item>-item_amount + lv_tax_amount .
ENDLOOP.
CLEAR lv_tax_amount.
lv_gross_amount = lv_gross_amount + lv_amount.
ENDIF.
ENDLOOP.
ls_header-gross_amount = lv_gross_amount.     "Enter the gross amoun

CLEAR : lv_count,lv_gross_amount,lv_amount,
lv_invno,lv_fyear,lv_tax_amount.

***Bapi to Create Credit-Memo
CALL FUNCTION 'BAPI_INCOMINGINVOICE_CREATE'
EXPORTING
headerdata       = ls_header
IMPORTING
invoicedocnumber = ex_invno
fiscalyear       = lv_fyear
TABLES
itemdata         = lt_item
return           = ex_return.

IF ex_invno IS NOT INITIAL AND lv_fyear IS NOT INITIAL.
CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
EXPORTING
wait = abap_true.
ls_return-message_v1 = ex_invno.
ls_return-message_v2 = lv_fyear.
ls_return-message    = 'The Credit-Memo & is Created'.
REPLACE '&' IN ls_return-message WITH ex_invno.
ls_return-type       = 'I'.
ls_return-number     = '001'.
APPEND ls_return TO ex_return.
ENDIF.

ENDMETHOD.
*        lv_gross_amount = lv_gross_amount + ( ( <lfs_ekpo>-effwr / <lfs
